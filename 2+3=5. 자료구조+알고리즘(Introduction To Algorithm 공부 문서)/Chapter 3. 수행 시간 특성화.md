# 수행 시간 특성화

이전 문서에서 알고리즘의 수행 시간을 나타내는 차수는 효율성에 대한 특성과 알고리즘들의 상대적인 성능을 비교할 수 있게 해준다. **입력 크기 n이 충분히 커짐에 따라** 병합 정렬이 삽입 정렬보다 훨씬 좋다.

때떄로 알고리즘의 정확한 수행 시간을 알아낼 수 있다 하더라도 보통의 경우엔 이정도로까지 정확성을 계산할 가치는 없다. 입력이 충분히 커지면 정확한 수행 시간의 상수 계수와 저차항은 입력의 크기에 묻혀 버리기 때문이다.

**`알고리즘의 점근적 효율성`** 에 관해 학습할 때는 충분히 큰 입력 크기에 대해 수행 시간 증가의 차수만 중요하게 취급된다. 대부분의 경우에는 크기가 아주 작은 입력을 제외하면 점근적으로 더 효율적인 알고리즘이 가장 좋은 선택이 될 것이다.

- 점근적이라는 말은 무엇일까? **점근적**이라는 말은 수학적 용어에서 비롯된 것으로, 무한히 가까워지는 성질을 뜻한다. 더욱 구체적으로 말하면 함수가 특정 값에 가까워지거나 무한으로 갈 때 그 근처에서 어떤 성질을 보이는지 연구하는 것을 의미한다.

- 여기서 우리가 분명히 해야할 포인트가 있다. 내가 이걸 처음 읽고 공부할 때만 해도 n의 크기를 상상할때 현실의 데이터를 대압했다. 그러나 이 문서에서 말하는 충분히 큰 입력이란 수학에서 말하는 **극한으로 증가할 때**를 의미한다. 현실 세계에서의 충분히 큰 입력값은 얼마로 생각하면 될까? 대략 10^6(1백만) 이상의 수만 생각해도 유효할 것이다.

- 최종적인 결론을 내자면 **점근적**이란, 입력 크기 n이 매우 커질 때 알고리즘의 성능(시간/공간)이 보여주는 경향성을 나타내는 말을 뜻한다.

해당 문서에서는 점근적 분석을 간단히 할 수 있는 여러 방법들을 소개한다. 다른 문서에서도 사용될 여러 표기법을 설명한 후 알고리즘의 분석에서 자주 등장하는 함수의 특정을 살펴본다.

### Ο-표기, Ω-표기, Θ-표기

#### 들어가기 전
이전 문서들에선 Θ(세타)를 단순히 O로 표현했을 것이다. 그 점을 유의해주길 바란다.

삽입 정렬의 최악의 경우 수행 시간을 분석했을 때 다음과 같은 복잡한 식으로 표현할 수 있었다.

```
(c5/2 + c6/2 + c7/2)n^2 + (c1 + c2 + c4 + c5/2 - c6/2 - c7/2 + c8)n - (c2 + c4 + c5 + c8)
```

여기서 하위항들을 삭제하고 n^2의 계수도 무시한다. 이렇게 하면 n^2만 남게 되는데, 이를 Θ-표기에서는 Θ(n^2)으로 표기한다. 알고리즘의 수행 시간을 특성화할 때 이 유형을 이용한다. 즉, 하위 항과 선행 항의 계수를 버리고 수행 시간의 증가율에 초점을 맞춘 표기법을 사용한다.

Θ-표기만이 이러한 `점근적 표기법`은 아니다. 다른 형태의 표기도 살표보는데, 먼저 직관적으로 살펴보고 삽입 정렬을 다시 보면서 어찌 적용하는지에 대해 살펴본다. 그 후 구체적인 정의와 사용 규칙을 살펴볼 것이다.

앞으로 보게 될 점근적 표기법은 일반적으로 함수를 특정짓기 위해 고안되었다는 점을 기억하자. 우리는 지금 **알고리즘의 수행 시간**이라는 함수에 대해 가장 관심이 크다.

그러나 점근적 표기는 알고리즘의 다른 관점(사용하는 공간의 양 등)을 나타내는 함수나 심지어 **알고리즘과 아무 관계없는 함수**에도 적용될 수 있다.


#### Ο-표기

Ο-표기는 점근적으로 함수의 상한을 나타내기 위해 사용된다. 즉 함수가 최고차 항을 기준으로 특정 속도보다는 빠르게 증가하지 않음을 나타낸다. 심플한 예시를 들어보자.
7n^3 + 2n^2 + 5n 이라는 함수가 있다고 치자. 이 함수의 최고차 항은 7n^3이므로 증가율은 n^3이다. 그렇다면 이 함수는 n^3보다 빠르게 증가하진 않을 것이다.

결국 이 함수는 Ο(n^3)이라고 쓸 수 있다. 이뿐만이 아니다. 해당 함수는 **Ο(n^4)** 나 **Ο(n^5)** 로도 쓸 수 있다. 해당 함수는 n^4나 n^5보단 느리게 증가하기 때문이다.
이 표기를 내 식대로  "해당 알고리즘의 최악의 경우 성능은 입력 크기의 증가에 따라 특정 상한선을 넘지 않는다." 정도로 말할 수 있다.

#### Ω-표기

Ω-표기는 반대로 함수의 하한을 나타낸다. 즉, 함수가 적어도 특정 비율만큼 빠르게 증가함을 의미하며, Ο-표기과 마찬가지로 최고자 항을 기준삼는다. 7n^3 + 2n^2 + 5n 함수에서 최고차 항은 적어도 n^3만큼 빠르게 증가하므로 이 함수는 Ω(n^3)이다. 이는 곧 Ω(n^2), Ω(n)으로도 표기가 가능하다.

이 표기를 내 식대로 "해당 알고리즘은 어떤 상황에서도 최소한 입력 크기만큼의 실행 시간은 보장된다." 정도로 말할 수 있다.

#### Θ-표기

Θ-표기는 점근적으로 함수의 위와 아래를 엄격하게 한계짓는다. 이는 함수가 다시 한 번 최고차 항을 기준으로 특정 비율로 정확하게 증가함을 의미하며, 이는 곧 Θ-표기는 함수의  위쪽 아래쪽에서 일정한 계수 이내로 증가하는 것을 의미한다. 다만 위아래의 상수 계수가 같을 필요는 없다.

이를 **어떤 함수 f(n)에 대해 함수가 O(f(n))이면서 Ω(f(n))임을 보여줄 수 있다면, 그 함수는 Θ(f(n))임을 증명한 것이다** 라고 정의할 수 있다. 앞서 사용한 7n^3 + 2n^2 + 5n 함수는 Ω(n^3)이면서 Ο(n^3)이므로 Θ(n^3)이기도 하다.

#### 예: 삽입정렬

삽입 정렬의 합계룰 평가하지 않고 점근적 표기로 작업하여 Θ(n^2) 최악의 수행 시간을 특성화하는 방법을 살펴보자. 다음 INSERTION-SORT 프로시저를 다시 살펴보자.

```
INSERTION-SORT(A, n)
1  for i = 2 to n
2    key = A[i]
3    // A[i]를 정렬된 배열 A[1:i-1]에 삽입한다.
4    j = i - 1
5    while j > 0 and A[j] > key
6        A[j + 1] = A[j]
7        j = j - 1
8    A[j + 1] = key
```

해당 프로시저에는 중첩 루프가 있다. 외부 루프는 정렬되는 값에 관계 없이 n-1회 실행되는 for 루프다. 내부 루프는 while 루프이지만 반복 횟수는 정렬되는 값에 따라 달라진다. 루프 변수 j는 i - 1에서 시작하여 0 또는 A[j] <= key에 도달할 때까지 각 반복에서 1씩 감소한다.

주어진 값 i에 대해 while 루프는 0회, i-1회 또는 그 사이의 모든 횟수를 반복할 수 있다. while 루프의 바디(6-7)는 반복마다 일정 시간이 걸린다.

이러한 관찰을 통해 INSERTION-SORT의 모든 경우에 대해 O(n^2)(n^2보다는 빠르게 증가하지 않는다.) 수행 시간을 추론할 수 있으며, 모든 입력에 대한 포괄 문을 제공한다.(즉 어떤 입력이 주어지더라도 O(n^2)은 항상 맞는 설명이다) 

수행 시간은 내부 루프에 의해 지배된다. 외부 루프를 n - 1번 반복할 떄 마다 내부 루프가 최대 i - 1번 반복한다. i는 최대 n이므로 내부 루프의 총 반복 회수는 최대 (n-1)^2이며, 이는 n^2보다 작다. 

내부 루프의 각 반복에는 상수 시간이 걸리므로 내부 루프에서 총 소요시간은 최대 상수 * n^2, 즉 O(n^2)이다.

해당 프로시저의 최악의 수행 시간이 Ω(n^2)이라는 것도 알 수 있다. 최악의 수행 시간이 Ω(n^2)이라는 말은 특정 임계값을 초과하는 모든 입력 크기 n에 대해 알고리즘이 최소 cn^2 시간이 걸리는 크기 n의 입력이 하나 이상 있음을 의미하며, **모든 입력에 대해 알고리즘이 반드시 최소 cn^2 시간이 걸린다는 의미는 아니다.**

INSERTION-SORT의 최악의 수행 시간이 Ω(n^2)인 이유를 살펴보자.

값이 시작된 위치의 오른쪽에서 끝나려면 6행에서 값을 이동해야 한다. 실제로 값이 시작된 위치에서 오른쪽으로 k번째 위치까지 이동햐려면 6행을 k번 실행해야한다.

어떠한 배열 A를 n/3 위치 그룹으로 나눌 수 있도록 n이 3의 배수라고 가정해보자.(더욱 쉽게 6으로 가정해서 따라가면 이해가 쉽게 될 것이다.) INSERTION-SORT에 대한 입력에서 n/3의 가장 큰값이 첫번째 n/3 배열 위치 A[1:n/3]을 차지한다고 가정한다.(즉, 가장 배열에서 큰 수들이 왼쪽에 위치하는 것이다. 여기서 첫 n/3 내에서 어떤 상대적 순서를 가지는지는 중요하지 않다.)

배열이 정렬되면 이러한 각 n/3값은 마지막 n/3 위치 [2n/3 + 1: n]의 어딘가에 위치하게 된다. 이렇게 되려면 값 각각들이 중간 n/3위치 [n/3 +1 : 2n/3]을 통과해야한다. 이러한 각 n/3 값은 6행의 최소 n/3 실행에 의해 한 번에 한 위치씩 중간 n/3 위치를 통과한다.

**최소 n/3개의 값이 최소 n/3개의 위치를 통과해야 하므로 최악의 경우 걸리는 시간은 적어도 (n/3)^2= n^2/, 즉 Ω(n^2)에 비례한다.**

INSERTION-SORT가 모든 경우에 O(n^2) 시간 내에 실행되고, Ω(n^2) 시간이 걸리는 입력이 있다는 것을 보여주었으므로 해당 프로시저의 최악의 수행 시간은 Θ(n^2)이라는 결론을 내릴 수 있다. 상한과 하한에 대한 상수 계수가 다를 수 있음은 중요하지 않다. 중요한 것은 **최악의 수행 시간을 상수 계수 이내로 제한했다는 것이다.**

물론 이 논의는 모든 경우에 Θ(n^2) 시간 내에 실행된다는 것을 보여주지 않는다. 실제로 삽입 정렬의 초선의 수행 시간은 Θ(n)이라는 것을 보였다.

## 점근적 표기 : 공식적인 정의

이제는 좀 더 공식적으로 살펴보자. 알고리즘의 점근적 수행 시간을 설명하기 위해 사용하는 표기접은 일반적으로 자연수 집합 N 또는 실수 집합 R인 함수의 관점에서 정의한다. 이러한 표기법은 수행 시간 함수 T(n)을 설명할 떄 편리하다.

기본적인 점근적 표기법을 정의하고 일반적인 표기법 남용 사례도 몇 가지 소개한다.

### O-표기

O-표기는 **점근적 상한**을 설명한다. 함수의 상한을 상수 계수 이내로 지정할 때 O-표기를 사용한다.(말이 어려울 수 있는데 최고차 항의 상수 생략을 의미한다)

다음은 O-표기의 공식적인 정의다. 주어진 함수 g(n)에 대해 함수 집합을 O(g(n))("n의 빅오(big-oh) 또는 "n의 오(oh)"라고 한다)으로 표시한다. 

```
O(g(n)) = {f(n) : 모든 n >= n0에 대해
            0 <= f(n) <= cg(n)인 양의 상수 c와 n0이 존재한다.}
```

충분히 큰 n에 대해 f(n) <= cg(n)이 되는 양의 상수 c가 존재하면 함수 f(n)은 집합 O(g(n))에 속한다. O(g(n))의 정의에서 O(g(n)) 집합의 모든 함수 f(n)은 점근적으로 음이 아니다라는, 즉 n이 충분히 클 때 f(n)이 음이 아니라는 조건이 필요하다(점근적으로 양인 함수는 충분히 큰 모든 n에 대해 양인 함수를 말한다.)
  - 어렵게 써져있어서 그렇지만 결국 입력값이 충분히 크다면 해당 알고리즘의 리턴값이 음수가 아님을 보장한다는 뜻이다.

따라서 함수 g(n) 자체가 반드시 점근적으로 음이 아니어야 되며, 그렇지 않으면 해당 집합은 공집합이 된다. 앞으로 O-표기로 사용된 함수는 모두 점근적으로 음이 아니라고 가정할 것이다. 그리고 이 가정은 다른 표기에서도 성립된다.

O-표기를 집합의 관점에서 정의한다는 사실은 꽤나 놀랍다. 실제로는 f(n)이 집합 O(g(n))에 속한다는 것을 나타내려면 "f(n) ∈ O(g(n))"과 같이 쓰는게 맞다. 그렇지만 같은 개념을 표현하기 위해 "="등호를 사용하고 "f(n)은 g(n)의 빅오다" 라고 말할 것이다.

집합의 포함 관계를 나타내기 위해 이렇게 등호를 사용하는게 처음에는 혼란스러울 수 있어도 추후 이러한 방법의 장점을 알게 될 것이다.

O-표기의 공식 정의를 사용해 최고차 항만을 남기는 관행을 정당화 하는 방법의 예로 들어 보겠다. 여기서 하위 항이 상위 항보다 계수가 훨씬 큰 함수 4n^2 + 100n + 500을 O(n^2)임을 보인다.

모든 n>=n0에 대해 해당 함수가 cn^2보다 작거나 같도록 양의 상수 c와 n0을 찾아야한다. 여기서 양변을 n^2으로 나누면 다음과 같다.
```
4 + 100/n + 500/n^2 <= c
```

이 부등식을 만족하는 c와 n0은 많다. 예를 들어, n0 = 1을 선택하면 c = 604에 대해 유지된다. n0 = 10이라면 c = 19가 적용된다.

또한 O-표기의 공식 정의를 사용해 n^2의 계수가 큰 음수라도 함수 n^3 - 100n^2가 집합 O(n^2) 속하지 않음을 보여줄 수 있다. 해당 함수가 = O(n^2) 이라면 모든 n>=n0에 대해 `n^3 - 100n^2 <= cn^2` 이 되도록 하는 양의 상수 c와 n0이 있을 것이다.

아까와 마찬가지로 양쪽을 n^2으로 나누면 `n - 100 <= c` 가 된다. 상수 c에 대해 어떤 값을 선택하든 이 부등식은 `n > c + 100`의 어떤 값에도 적용되지 않는다.
- 우리가 여기서 잊지 말하야할 것은 n은 **무한으로 증가하는 자연수**로 정의되는 수이다. 즉 고정된 상수 c가 아무리 커봤자 무한으로 가까워지는 n에 -100을 한 것보다 같거나 클 수는 없다는 소리다.

### Ω-표기

Ω-표기는 점근적 하한을 제시해준다. 주어진 함수 g(n)에 대해 Ω(g(n))("빅-오메가 g(n)" 또는 "오메가 g(n)"이라고 한다) 은 다음과 같은 함수들의 집합으로 나타낸다.

```
Ω(g(n)) = {f(n) : 모든 n>=n0에 대해 0 <= cg(n) <= f(n))인 양의 상수 c와 n0이 존재한다.
```

우리는 이미 4n^2 + 100n + 500 = O(n^2)임을 보였다. 이제는 Ω(n^2)임을 증명해보겠다. 아까와 마찬가지로 모든 n>=n0에 대해 4n^2 + 100n + 500 >= cn^2이 되도록 양의 상수 c와 n0을 찾아야한다. 이전과 마찬가지로 양변을 n^2으로 나누면 다음과 같다.
```
4 + 100n + 500/n^2 >= c
```

이 부등식은 n0이 임의의 양의 정수이고 c=4일 때 유지된다.

4n^2 항에서 하위 항을 더하는 대신 빼면 어떨까? n^2항에 작은 계수가 있다면? 그럼에도 함수는 여전히 Ω(n^2)가 될 것이다. 예를 들어, `n^2/100 - 100n - 500 = Ω(n^2)`임을 보이겠다. n^2으로 똑같이 나눌 때 n0에 대해 최소 10005 이상인 값을 선택하고 c의 양수 값을 찾을 수 있다. 예를 들어 n0이 10005일 때 c = 2.49 * 10^-9을 선택할 수 있다.
이는 c의 작은 값이지만 양수이다. n0에 더 큰 값을 선택하면 c를 늘릴 수도 있다. n0 값이 클수록 계수 1/100에 가까울수록 c를 선택할 수 있다.

### Θ-표기

**점근적으로 엄밀한 경계** 에는  Θ-표기를 사용한다. 주어진 함수 g(n)에 대해 Θ(g(n))("n의 g의 세타")으로 함수의 집합을 표시한다.

```
Θ(g(n)) = {f(n) : 모든 n>=n0에 대해
        0 <= c1g(n) <= f(n) <= c2g(n)인 양의 상수 c1, c2, n0이 존재한다.
```

이러한 표기들의 정의로부터 다음과 같은 중요한 정리를 이끌어 낼 수 있다. 

**임의의 두 함수 f(n)과 g(n)에 대해 f(n) = Θ(g(n))이면 f(n)= Ω(g(n)), f(n) = O(g(n))이고 그 역도 성립한다.**
- 역이 성립한다는 말을 바꾸어 말하면 **f(n)이 O(g(n)) 이고 동시에 Ω(g(n))이면 f(n) = Θ(g(n))라는 의미이다.

#### 해당 정리의 증명(연습문제라 별도로 씀)
f(n) = Θ(g(n))의 정의를 잘 생각해보면  c1g(n) <= f(n) <= c2g(n)이다. 이는 곧,
f(n) = O(g(n)) : f(n) <= c2g(n)
f(n) = Ω(g(n)) : f(n) >= c1g(n) 으로 나눌 수 있다는 것이다.
특정 함수 4n^2 + 100n + 500 가 존재한다고 가정할 때  세타 n^2이라면 c1n^2 <= 4n^2 + 100n + 500 <= c2n^2를 성립하게 해주는 양의 상수 c1, c2, n0 가 존재한다.
각 함수를 모두 n^2으로 나누어 보자. 그럼 다음과 같다. c1 <= 4 + 100/n + 500/n^2 <= c2
여기서 n0이 어떠한 양의 상수이든 4보다는 크므로 c1이 4일 경우 성립이 된다. 여기서 만약 n0이 1이라면 c2는 604로서 성립된다. 즉 이 문제를 나누어 보면 빅오 n^2과 오메가 n^2임을 동시에 증명한다.

### 점근적 표기와 수행시간

알고리즘의 수행 시간을 특성화하기 위해 점근적 표기를 사용할 때는 어떤 수행 시간에 적용되는지 과장하지 않고 최대한 정확한 점근적 표기를 사용해야한다. 다음은 수행 시간을 특성화 하기 위해 표기를 적절히 사용하는 몇가지 경우와 그 반례들을 알아보겠다.

삽입 정렬의 경우를 생각해보자. 최악의 경우 수행시간은 O(n^2), Ω(n^2), Θ(n^2) 이라고 정확히 말할 수 있다. 세 가지 방법 모두 정확하지만 통상적으로 Θ(n^2) 힌계가 가장 선호된다.

최상의 수행 시간은 어떠한가? O(n), Ω(n), Θ(n)이며, 다시 Θ(n)이 가장 정확하므로 가장 선호된다고 말할 수 있다.

여기서 중요한건 **삽입 정렬의 수행 시간은 Θ(n^2)이라고 정확히 말할 수는 없다**는 점이다. 앞에 "최악의 경우" 라는 말을 생략하면 모든 경우를 포괄하는 포괄적인 문이 남기 떄문에 과장된 표현이 된다.

해당 오류는 삽입 정렬이 **모든** 경우에 Θ(n^2) 시간 내에 실행되지 않는다는 것이다. 그러나 삽입 정렬의 수행 시간은 모든 경우에서 n^2보다 빠르게 증가하지는 않기 때문에, O(n^2)이라고 정확하게 말할 수 있다. 마찬가지로  수행 시간이 Θ(n)이라고 정확히 말할 수는 없지만, Ω(n)이라고 말할 수는 있다.

병합 정렬은 어떨끼? 병합 정렬은 모든 경우에 Θ(n lg n) 시간 내에 실행되므로 최악의 경우, 최상의 경우 등등 여러 경우를 지정하지 않고 그냥 수행 시간이 Θ(n lg n)이라고 말할 수 있다.

일반적으로 가장 간단하고 정확한 한계를 제공하기 위해 점근적 표기를 사용한다. 예를 들어 알고리즘의 수행 시간이 모든 경우에 3n^2 + 20n인 경우, 점근적 표기를 사용해 Θ(n^2)이라고 표기한다. 엄밀히 말하면 O(n^3)이라고 써도 되고 Θ(3n^2 + 20n) 이라고 써도 된다. 그러나 이 경우 두 표현식 모두 Θ(n^2)을 쓰는것 만큼 유용하지 않다.

O(n^3)은 Θ(n^2)보다 정확도가 떨어지고, Θ(3n^2 + 20n)은 증가율을 모호하게 만드는 복잡성을 유발한다. Θ(n^2)과 같이 가장 간단하고 정확한 한계를 작성함으로싸 다양한 알고리즘을 분류하고 비교할 수 있다.


### 방정식과 부등식의 점근적 표기

공식적으로는 점근적 표기를 집합의 관점에서 정의하지만, 수식에서 집합 기호 ∈ 대신 = 기호를 사용한다. 이러한 수식을 어떻게 해석할까?

4n^2 + 100n + 500=O(n^2)와 같이 방정식(또는 부등식)의 오른쪽에 점근적 표기가 단독으로(즉, 더 큰 수식 안에 있지 않을 때) 있을 때 등호는 집합의 4n^2 + 100n + 500 ∈ O(n^2)을 의미한다.

그러나 일반적으로 수식에 점근적 표기가 나타나면 특정하지 않아도 되는 **익명 함수**를 나타내는 것으로 해석한다. 
예를 들어 2n^2 + 3n + 1 = 2n^2 + Θ(n)이라는 식을 생각해보자. 이 식은 다르게 바꾸면 2n^2 + 3n + 1 = 2n^2 + f(n)을 의미하며 여기서 f(n) ∈ Θ(n)을 의미한다. 이 경우 f(n) = 3n + 1은 실제로 Θ(n)에 속한다.
  - 익명 함수란 특정 이름 없이 정의된 함수 표현으로, 간단한 연산이나 규칙을 표현할 때 주로 사용한다. 여기선 구체적인 세부사항 없이 함수의 증가율만 남긴 점근적 표현을 의미한다. 계속 반복해서 말한 하위 항들과 계수의 생략을 의미한다고도 볼 수 있다.

이러한 방식으로 점근적 표기를 사용하면 방정식에서 불필요한 세부 사항과 복잡함을 제거하는 데 도움이 될 수 있다. 예를 들어, 병합 정렬의 최악의 수행시간을 다음과 같이 표현했었다.

```
T(n) = 2T(n/2) + Θ(n)

2번 문서와 다르게 이젠 정확한 표기인 Θ를 사용한다.
```

T(n)의 점근성에만 관심이 있는 경우, 모든 하위 차수 항은 Θ(n)이라는 익명함수에 모두 포함되는 것으로 이해되므로 모든 하위 차수 항을 정확히 지정할 필요가 없다.

다음과 같이 방정식의 왼쪽에 점근적 표기가 표시되는 경우도 있다.

```
2n^2 + Θ(n) = Θ(n^2)
```

다음과 같은 규칙을 사용하여 이러한 방정식을 해석한다. 등화 왼쪽에 있는 익명 함수를 어떻게 선택하든 오른쪽에 있는 익명 함수를 선택하면 방정식을 유효하게 만들 수 있다. 따라서 이 예는 모든 함수 f(n) ∈ Θ(n)에 대해 2n^2 + f(n) = g(n)이 되는 함수 g(n) ∈ Θ(n^2)이 있음을 의미한다. 즉, 방정식의 오른쪽에 있는 익명 함수는 왼쪽보다 더 포괄적이다.

다음과 같이 이러한 관계를 여러 개 연결할 수 있다.

```
2n^2 + 3n + 1 = 2n^2 + Θ(n) = Θ(n^2)
```

위의 규칙에 따라 각 방정식을 개별적으로 해석한다. 
1. 첫 번쨰 방정식은 모든 n에 대해 2n^2 + 3n + 1 = 2n^2 + f(n)이 되는 어떤 함수 f(n) ∈ Θ(n)이 있다고 말한다.
2. 두 번째 방정식은 방금 언급한 f(n)과 같은 어떤 함수 g(n) ∈ Θ(n)의 경우, 모든 n에 대해 2n^2 + g(n) = h(n)이 되는 어떤 함수 h(n) ∈ Θ(n^2)이 있다고 말한다.
3. 최종적으로 이 해석은 2n^2 + 3n + 1 = Θ(n^2)을 의미하는 것이며, 이는 방정식의 연쇄가 직관적으로 말하는 바와 같다.

### 점근적 표기의 올바른 남용
