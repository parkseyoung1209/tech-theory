# 개요

해당 문서의 의사코드들을 제대로 읽기 위해서 규칙들을 정리한 문서이다. 문서의 기반이 되는 Introduction To Algorithm의 의사코드 규칙을 그대로 따랐다. 규칙의 구체적인 예시는 다음가 같다.

```
INSERTION-SORT(A, n)
1  for i = 2 to n
2    key = A[i]
3    // A[i]를 정렬된 배열 A[1:i-1]에 삽입한다.
4    j = i - 1
5    while j > 0 and A[j] > key
6        A[j + 1] = A[j]
7        j = j - 1
8    A[j + 1] = key
```

1. 들여쓰기는 블록 구조를 나타낸다. 예를 들어, 1행에서 시작한 for 루프의 바디 부분은 2~8행으로 구성되고, 5행에서 시작한 while 루프는 6~7행을 포함하지만 8행은 포함하지 않는다.
이러한 들여쓰기 스타일은 **if-else**에도 똑같이 적용된다.
  - if-else 문에서는 일지하는 if와 같은 수준에서 else를 들여쓰기 한다.
  - else 절의 첫번째 실행 줄은 키워드 else와 같은 행에 나타난다. 다중 방향 검사의 경우, 첫번째 검사 이후 검사에 elseif를 사용한다.
  - else 절의 첫번째 행인 경우 다른 절로 오해하지 않도록 다른 절 다음 행에 if문이 나타난다.
    <br/>
    
2. while, for, repeate-until 같은 반복문과 if, then, else 같은 조건문은 C,C++,자바 등과 비슷하게 해석된다.
그러나 for 루프의 경우에는 다소 차이가 존재하는데, 여기선 루프의 카운터가 루프를 빠져나간 후에도 값을 유지한다.
하지만 c++이나 자바에서는 루프를 빠져나올 때 루프 카운트 변수의 값이 정의되지 않은 값이 정의 되지 않은 값으로 바뀐다.
즉 for 루프를 빠져나온 순간의 루프 카운트 값은 루프를 처음으로 빠져나올때의 값이다.
for 루프가 루프 카운터를 증가시킬때는 to 키워드를 사용하고 감소 시킬때는 downto 키워드를 사용한다.
루프 카운터가 1보다 큰값으로 변경되면, 변경된 값은 by 키워드를 따른다.

3. // 기호는 주석을 나타낸다.

4. i, j, key와 같은 변수는 프로시저에서의 지역 변수다. 이 책에서는 전역 변수를 사용할 경우에는 이를 분명히 명시한다.

5. 배열의 원소는 배열 이름 다음에 있는 [] 안의 인덱스를 사용해 내용에 접근한다. 예를 들어 A[i]는 배열 A의 i번째 원소를 나타낸다.

6. 대부분의 프로그래밍 언어에서 사용하는 0에서 시작하는 인덱싱이 아닌 1에서 시작하는 1-원점 인덱싱 체계를 선택한다.
특정 알고리즘이 어떠한 인덱싱 체계를 가정하는지 명확히 하기 위해 배열의 경계를 명시적으로 지정한다. 실제 코드로 작성하는 경우 스스로 조정할 수 있을 것이다.

7. ":" 표기는 하위 배열을 나타낸다. 따라서 A[i:j]는 A[i], A[i + 1], ... A[j] 원소로 A의 부분 배열을 나타낸다. 또한 배열의 경계를 나타낼 때도 이 표기법을 사용한다.

8. 일반적으로 복합 데이터는 객체 형태로 만들어지며 객체는 필드로 구성된다.
특정 속성(필드) 값은 다른 객체 지향 프로그래밍에서 흔히 볼 수 있듯이 객체 이름 다음에 점을 찍고 속성 이름을 써 접근할 수 있다.
예를 들어 객체 x에 속성 f가 있는 경우 이 속성을 x.f로 표시한다.
배열과 같은 객체를 나타내는 변수는 그 내용을 담고 있는 데이터에 대한 포인터(일부 프로그래밍 언어에서는 참조라고 함)로 취급한다.
y = x 명령문이 실행되면 객체 x의 모든 속성 f에 대해 y.f가 x.f와 같아진다.
또한 x.f = 3을 실행하면 x.f는 물론 y.f 값도 3이 된다. 즉 y = x 할당문이 실행되면 x와 y는 동일한 객체를 가리키게 된다.
속성을 연속으로 붙여 사용할 수 있다. 예를 들어, 속성 f 스스로가 속성 g를 갖는 객체의 포인터라고 하자. 이런 경우 x.f.g에 (x.f).g와 같이 소괄호가 들어가 있다고 본다.
즉, y = x.f로 할당하면 x.f.g와 y.g는 같은 표현이 된다.
포인터가 아무 객체도 가리키지 않을 수 있다. 이 경우 해당 포인터에 NIL이라는 특수한 값을 준다.

9. 프로시저의 매개변수들은 값에 의해 전달된다(call by value).
피호출 프로시저는 매개변수에 대해 복사본을 가지며, 피호출 프로시저에서 매개변수에 어떤 값을 할당하더라도 호출 프로시저에서 값의 변화를 모른다.
객체가 전달되면 객체의 데이터를 가리키는 포인터는 복사되지만 그 객체의 속성은 복사되지 않는다.
에를 들어, x가 피호출 프로시저의 매개변수 일 때 피호출 프로시저에서 x = y를 할당하는 것은 호출 프로시저에서는 확인할 수 없다.
그러나 x.f = 3과 같은 할당문은 호출 프로시저에서도 변화를 알 수 있다.
이와 비슷하게 배열을 함수의 매개변수로 쓸 때는 배열 전체를 넘기지 않고 배열의 포인터만 넘긴다.
이 경우에도 배열의 원소 값을 변화시키면 호출 프로시저에서 확인할 수 있다. 다시 말하지만, 대부분의 최신 프로그래밍 언어는 이러한 방식으로 작동한다.

10. return 문은 호출되는 즉시 호출 프로시저로 돌아간다.
대부분의 return 문은 값을 호출 프로서지로 보낸다.
이 문서의 의사코드에서는 여타 프로그래밍 언어들과 달리 하나의 return 문으로 여러 값을 리턴할 수 있다.

11. "and" 와 "or" 같은 이진 논리 연산자는 **조기 차단** 할 수 있다. 즉 "x and y" 문에서 x를 먼저 계산한다.
x가 FALSE이면 식의 결과가 TRUE가 될 수 없으므로 y를 계산조차 하지 않는다. 반면 x가 TRUE이면 식의 결과를 계산하기 위해 y 값도 반드시 계산해야 한다.
이렇게 조기 차단되는 연산자를 사용하면 "x ≠ NIL and x.f = y" 와 같은 이진 논리식에서 x가 NIL인 경우 x.f를 계산할 때 어떤 상황이 벌어질지 걱정하지 않고 사용할 수 있다.

12. error는 프로시저가 호출되는 동안 조건이 잘못되어 오류가 발생함을 의미한다.
발생한 오류에 대한 처리는 호출 프로시저에서 이루어지므로 프로시저에서는 오류 처리를 명시하지 않는다.
