# 개요

알고리즘을 설계하고 분석하기 위해 이 책 전반에 걸쳐 사용하는 체계를 알아본다.
현재 해당 문서에서 서술된 내용을 이해하는데 필요한 내용을 대부분 담아보려고 한다. 다만 일부는 다른 문서에서 추가로 소개할 것이다.

시작은 이전 문서에서 소개한 삽입 정렬을 살펴보는 것으로 이 장을 시작한다. 전체 문서의 바탕이 되는 Introduction To Algorithm 교재에서는 알고리즘을 서술하기 위해  "의사코드"를 정의하여 이용한다. 아마 프로그래밍 언어 중 하나라도 익숙한 사람이라면 이해하기 쉬울 것이다.

삽입 정렬 알고리즘을 의사코드로 먼저 서술 후 그 알고리즘이 올바르게 정렬하는지 확인한다.
그리고 알고리즘의 수행 시간을 분석하는데, 이를 위해 정렬 대상 개수의 증가에 따른 수행 시간의 변화를 표현할 수 있는 표기법을 도입한다.
끝으로 삽입 정렬에 대해 더 자세히 알아보고, 알고리즘 설계 방법 중 하나인 분할 정복에 대한 소개와 이를 이용한 병합 정렬 알고리즘을 살펴보고 수행시간까지 분석하는 것으로 이 문서는 끝난다.


## 삽입 정렬

이전 문서에서 소개한 정렬 문제를 풀기 위해 문제를 다음과 같이 정의해본다.

```
입력 : n개 수들의 수열(a₁, a₂, ..., aₙ)
출력 : a'₁ ≤ a'₂ ≤ a'₃,... ≤ a'ₙ 을 만족하는 입력 수열의 순열(재배치) (a'₁, a'₂,... a'ₙ )
```

정렬할 숫자는 키(key)라고도 한다. 개념적으로는 수열을 정렬하는 문제이지만, 입력은 n개의 원소가 있는 배열의 형태로 제공된다. 숫자를 정렬하려는 경우, 숫자가 다른 데이터와 연관된 키인 경우가 많은데, 이를 **부속 데이터**라고 한다.
키와 부속 데이터는 하나의 **레코드**를 형성한다. 정렬 알고리즘을 설명할 때는 키에 초점을 맞추지만, 일반적으로 연관된 부속 데이터가 있다는 점을 기억하는 것이 중요하다.

- 심플하게 생각해보자. 프로그래머 입장에서 중요한 것은 단순히 숫자를 배열하는 것이 아니라, 레코드의 키 값을 기준으로 정렬하면서 부속 데이터가 해당 키와 올바르게 대응되도록 보장하는 것이다.
- 만약 자바 객체가 있고, 특정 필드만 정렬된 후 정렬된 필드 값을 기준으로 조회했을 때 부속 데이터가 엉뚱한 값을 반환한다면 이는 명백한 오류이다.(물론 객체로 만들었다는 것 자체가 이런 일이 일어나기가 어렵다..)

재차 말하지만 해당 문서를 포함한 전체 문서는 알고리즘을 **의사코드**로 표현한다. 여타 다른 프로그래밍 언어를 접해보았다면 어렵지 않게 이해할 수 있을 것이다.
- 의사코드와 실제 프로그램 코드의 차이는, 의사코드에서는 알고리즘을 명확하고 간결하게 서술할 수만 있다면, 어떤 표현 방법을 사용해도 좋다는 것이다.
- 예를 들어 어떤 경우에는 한글로 문장으로 서술하는게 제일 간결한 표현일 수도 있다.
- 또한 소프트웨어 공학 관점의 문제는 고려하지 않는데, 이는 곧 오류 처리 같은 문제는 무시될 수 있다는 것이다.

이제 크기가 작은 정렬에 효율적인 **삽입 정렬** 알고리즘으로 시작해보자.

삽입 정렬은 아마 사람이 실제로 어떠한 숫자를 정렬할 때 사용하는 방식과 가장 흡사한 방법이 아닌가싶다. 숫자가 쓰여져있는 카드 뭉치를 떠올려보자. 왼손은 비어있고 뒤집힌 카드 뭉치에서 카드를 한 장씩 가져와 왼손에다가 말 그대로 삽입하여 가져오는 것이다. 여기서 카드를 숫자 크기대로 정렬하겠다고 오른쪽에서 왼쪽 방향으로 새로운 카드를 기존 카드들과 쭉 비교하면 끝이다.

이런식이면 왼쪽에 있는 카드들은 항상 정렬되어 있을 것이다. 이 카드들은 처음 카드 뭉치에 있던 맨 위에 있던 카드들이다.

삽입 정렬을 위한 의사코드는 INSERTION-SORT 프로시저로 나와있다. 이 프로시저에는 두 개의 매개변수, 즉 정렬할 값을 포함하는 배열 A와 정렬할 값의 개수 n이 필요하다.
값은 배열의 A[1]에서 A[n]까지의 위치를 차지하며, 이를 A[1:n]으로 표시한다. INSERTION-SORT 프로시저가 완료되면 배열 A[1:n]에는 원래 값이 정렬된 순서대로 포함된다.

```
INSERTION-SORT(A, n)
1  for i = 2 to n
2    key = A[i]
3    // A[i]를 정렬된 배열 A[1:i-1]에 삽입한다.
4    j = i - 1
5    while j > 0 and A[j] > key
6        A[j + 1] = A[j]
7        j = j - 1
8    A[j + 1] = key
```

### 루프 불변성과 삽입 정렬의 타당성

인덱스 i는 왼손으로 가져가 정렬할 "현재 카드"를 나타낸다. for 루프에서 인덱스 i로 표시되는 반복이 시작될 때 **부분 배열** A[1:i-1]은 현재 손에 쥔 정렬된 카드이고 나머지 부분 배열 A[i + 1 : n]은 아직 탁자에 있는 카드더미이다. 즉 A[1:i-1]은 처음에 탁자에 쌓인 순서대로 맨 앞부터 i - 1번째까지의 값이지만 이제는 정렬되어 저장된 것이다. 해당 배열의 이런 특성을 엄밀하게 표현하면 **루프 불변성이라 한다.**

     좀 더 명확히 말하자면 루프 불변성이란 루프가 반복될 때마다 항상 참으로 유지되는 조건을 의미한다.
 
해당 프로시저의 루프 불변성
- **1~8행의 부분 배열 A[1:i-1]은 루프가 반복을 시작할 때마다 원래 A[1:i-1] 원소로 정렬된 순서로 구성된다.**

루프 불변성은 알고리즘이 타당한 이유를 쉽게 이해할 수 있도록 하기 위해 사용된다. 루프 불변성을 보이려면 다음 세 가지 특성을 만족해야 한다.

1. 초기화 : 루프가 첫 번째 반복을 시작하기 전에 참이다.
2. 유지 : 루프의 반복이 시작되기 전에 참이면 다음 반복이 시작되기 전에도 참이 유지된다.
3. 종료 : 루프가 종료될 때 그 불변식이 알고리즘의 타당성을 보이는 데 유용한 특성을 가져야 한다.

해당 조건의 1, 2번을 만족하면 루프가 시작할 때 루프 불변성은 항상 참이다. 여기서 유의해야할 점은 **매 루프를 시작하기 전에 루프 불변성이 유지됨을 보이기 위해 루프 불변성이 아닌 다른 사실을 이용해도 된다는 점이다.** 좀 더 명확히 말하자면, 루프 불변성을 유지하기 위해, 반드시 불변 조건(루프 불변성)만을 직접적으로 활용할 필요는 없고, 루프가 어떻게 작동하는지에 대한 다른 논리적 특성이나 외부의 맥락적 정보를 활용해도 괜찮다는 점이다.

3번 특성이 가장 중요한데, 결국 루프 불변성을 보이는 목적이 알고리즘의 타당성을 보이는 것이기 때문이다. 보통 루프의 종료 조건이 완료될 때까지 루프 불변성을 이용한다.
실제 수학에서 사용되는 일반적인 수학적 귀납법은 귀납적 과정이 무한히 반복되는데 반해 여기서는 루프가 종료될 때 귀납적 과정도 끝난다.

이제 삽입 정렬 알고리즘에서 이런 특성이 어떻게 만족되는지 살펴보자.

- **초기화** : 먼저 루프의 첫 반복이 시작되기 전, 즉 i = 2일 때 루프 불변성이 성립하는지를 살펴본다. 이때 부분 배열 A[1: i - 1]은 A[1] 한 개의 원소로 구성되는데, 애시당초 A[1]의 값 하나밖에 없다. 해당 부분 배열은 당연히 정렬되어 있으므로 루프의 반복 시작 전에 루프 불연성이 성립한다.

- **유지** : 다음으로 매 반복 시 루프 불변성이 유지되는지 살펴본다. 간단히 설명하면 for 루프의 바디 부분은 A[i]의 올바른 위치를 찾을 때까지 A[i - 1], A[i - 2], A[i - 3]을 오른쪽으로 한 자리씩 이동시키는 작업응 한 뒤(4~7)행 값을 적절한 위치에 삽입한다(8행). 그러면 배열은 기존 배열과 동일한 원소를 정렬한 상태로 갖게 된다. i가 1씩 증가하면서 for 루프의 다음 반복에서 루프 불변성이 유지된다.

- **종료** : 마지막으로, 루프가 종료되었을 때 어떤 상황이 발생하는지를 조사해본다. 삽입 정렬의 경우 for 루프는 i가 n보다 커질 때 종료한다. 루프 불변성에서 i에 n + 1을 대입하면 부분 배열 A[1 : n]은 원래 배열에 있는 원소들로 정렬한 순서대로 구성된다. 따라서 알고리즘은 타당하다. 


#### 의사코드 기반으로 짜본 자바 삽입 정렬

1. 기존(여기선 인덱스의 원점을 0으로 생각하고 구현했다)
```java
public void InsertionSort(Key[] A) {
  int n = A.length;
  for(int i = 1; i < n; i++) {
    Key key = A[i]; 
    int j = i -1;
    while(j >= 0 && A[j] > key) {
      A[j + 1] = A[j];
      j = j -1;
    }
    A[j + 1] = key;
  }
}
```

2. 내림차순
```java
//배열은 똑같이 5 2 4 6 1 3이라 가정하고  6 5 4 3 2 1로 만들어야함
public InsertionSort(Key[] a);
  for(int i = 1; i < a.length; i++) {
    Key key = a[i];
    int j = i - 1;
    while(j >= 0 && a[j] < key) {
      a[j + 1] = a[j];
      j = j - 1;
    }
    a[j + 1] = key;
  }
//달라진건 오직 while문의 비교 연산밖에 없다
```

#### 연습문제

2번

```
SUM-ARRAY(A, n)
1 sum = 0
2 for i = 1 to n
3   sum = sum + A[i]
4 return sum
```


초기화 : i가 1에서 시작할 때를 참인가를 묻는다. 여기서 불변 법칙은 A라는 배열에서 A[1:i]의 합이 리턴되느냐를 따짐.
A[0] 하나의값만이 있고 자기 자신과 아무것도 없는 걸 더해야하므로(0) 현재 A[0:i]의 합이 리턴되기에 루프 불변성이 유지된다.

유지 : 현재 for문에서 배열의 인덱스를 순차적으로 늘려가며 탐색중이고 해당 인덱스에 해당되는 값을 sum에다가 더한다. 즉 i -1, i-2, i-3..의 값이 sum에 누적되면서 더해지고 있다.
루프 불변성이 유지된다.

종료: 최종적으로 이 루프는 n + 1일때 종료되어 리턴한다. 현 루프에서 n + 1을 넣으면 이미 n을 넣었을때의 누적된 값이 sum에 더해져있는 상태로 리턴되므로 루프 불변성이 유지된다.

3번

```
INSERTION-SORT(A, n)
1  for i = 2 to n
2    key = A[i]
3    // A[i]를 정렬된 배열 A[1:i-1]에 삽입한다.
4    j = i - 1
5    while j > 0 and A[j] < key
6        A[j + 1] = A[j]
7        j = j - 1
8    A[j + 1] = key
```


## 알고리즘의 분석

알고리즘의 분석은 그 알고리즘을 실행하는 데 필요한 자원을 에측하는 것을 의미한다. 대부분의 경우에 측정 대상은 계산 시간이다. 일반적으로 어떤 문제를 해결할 수 있는 알고리즘이 여러 개이면 이를 분석하여 가장 효율적인 알고리즘을 쉽게 구분할 수 있다.

분석에 앞서 구현 기술의 모델을 잘 정의해야 하는데, 여기에는 그 기술에 필요한 자원과 비용에 관한 모델도 포함된다. 이 책에서는 대부분의 경우, 알고리즘이 단일 프로세서와 **RAM**(Random Access Machine, 랜덤 접근 기계) 모델에서 컴퓨터 프로그램으로 구현된다고 가정한다.
     - RAM 모델에서는 명령어는 동시에 수행되지 않고 차례로 하나씩 실행된다.
     - 변수값을 사용하거나 변수에 저장하는 것은 다른 데이터 접근과 동일한 시간이 걸린다.
     - 즉 RAM 모델에서는 각 명령어 또는 데이터 접근에 상수 시간이 걸리며, 심지어 배열로 인덱싱하는 경우에도 마찬가지이다.
엄밀하게는 RAM 모델에서의 명령어와 비용도 정확하게 정의해야 한다. 그러나 이는 실제 알고리즘 배움에 있어 그다지 도움이 되지는 못한다. 물론 실제 컴퓨터가 어떤 식으로 설계되어 있는지를 충분히 참고해야한다.

RAM 모델에서 데이터 형은 정수와 부동소수이다. **실제 컴퓨터에는 일반적으로 Bool값 true와 false에 대한 별도의 데이터 유형이 없다.**

데이터의 각 워드 크기에 제한이 있다고 가정한다. 또한 c를 상수로 제한하여 워드 크기가 임의로 커지지 않게 한다.

실제 컴퓨터에는 여러가지 명령어를 포함하고 있는데 예를 들어 지수 연산은 상수 시간 명령어인가? 일반적으로 그렇지 않으며 x와n이 일반 정수일때 x^n을 계산하려면 일반적으로 n의 로그 시간이 걸리며 결과가 컴퓨터 워드에 맞는지 고려해야 한다. 그러나 **x가 2의 정확한 거듭제곱인 경우 지수는 일반적으로 상수 시간 연산으로 볼 수 있다.**

RAM 모델에서는 현대의 컴퓨터에서 일반적으로 이용하는 메모리 계층을 고려하지 않는다. 다만 메모리 계층에 대한 효과가 실제 기계에서 실행되는 프로그램에서 중요한 요소가 되는 일부 계산 모델에서는 이를 고려한다. RAM 모델에 비해 메모리 계층을 고려한 모델은 상당히 까다로워 분석에 어려운 점이 많으나, 다행히 RAM 모델에서의 분석만으로도 실제 기계의 성능을 대체로 잘 예측할 수 있다.

RAM 모델에서 단순한 알고리즘을 분석하는 일도 상당히 어려운 일이 될 수 있다. 그리고 필요한 수학적 지식으로는 조합론, 확률론, 대수 기법, 식에서 가장 중요한 매개변수를 알아내는 방법 등이 있다. 알고리즘의 동작은 주어지는 입력에 따라 달라질 수 있으므로 그러한 동작을 간단하고 쉽게 이해할 수 있도록 이를 식으로 합할 수 있는 방법도 알아야한다.

### 삽입 정렬의 분석

해당 프로시저는 시간이 얼마나 걸릴까? 분명한건 환경에 따른 변수가 영향을 끼치는 실제 수행 시간을 측정하는 대신 알고리즘을 분석하여 소요 시간을 확인할 수 있다.
먼저 수행 시간에 대한 정확하지만 복잡한 식을 만들어 보겠다. 그 다음 중요한 부분만 추출해서 동일한 문제에 대한 여러 알고리즘의 수행 시간을 비교하는 데 유용한 표기법으로 표현한다.

삽입정렬은 어떻게 분석할까? 수행 시간은 입력에 의해 결정된다. 숫자 3개를 정렬하는 것과 1000개를 정렬하는 것은 다르니말이다. 또한 같은 크기의 입력 수열에 대해서도 어느정도 정렬되어 있느냐에 따라 수행 시간이 달라질 수도 있다.

일반적으로 입력 크기가 커질수록 알고리즘의 수행시간이 증가하므로 수행 시간을 입력크기의 함수로 표현한다. 이를 위해 "수행 시간"과 "입력 크기"를 더욱 제대로 정의할 필요가 있으며, 최악의 경우를 논의하는가, 최상의 경우를 논의하는가, 아니면 다른 경우에 대한 것인지도 명확히 해야한다.

**입력 크기**에 대한 가장 정확한 개념은 주어진 문제에 따라 다르다. 정렬이나 이산 푸리에 변환 계산 같은 경우에는 입력 항목의 개수가 될 수 있고, 두 정수를 곱하는 문제는 필요한 총 비트 수가 자연스러운 입력 크기의 척도가 될 수가 있다.

**수행 시간**은 연산과 데이터 접근 시간을 합한 것이다. 당분간은 이렇게 생각하자. **의사코드의 각 행을 수행하는 데 상수 시간이 소요된다.** 행마다 정확한 시간은 다를 수 있으므로 k행을 실행하는데 Ck 시간이 걸린다고 가정한다.

먼저 INSERTION-SORT 프로시저를 각 명령문의 실행에 따른 시간 비용과 실행 횟수를 고려해 살펴본다. 주석은 실행 가능한 명령문이 아니므로 시간이 걸리지 않는다.

```
INSERTION-SORT(A, n)                              비용     수행시간
1  for i = 2 to n                                 c1          n
2    key = A[i]                                   c2        n - 1
3    // A[i]를 정렬된 배열 A[1:i-1]에 삽입한다.    0         n - 1 
4    j = i - 1                                    c4        n - 1  
5    while j > 0 and A[j] > key                   c5        ∑₍ᵢ₌₂ⁿ₎ tᵢ // 유니코드에서 쓰이는거 그대로 쓴거라 실제 시그마 식이랑은 차이점이 있다.
6        A[j + 1] = A[j]                          c6        ∑₍ᵢ₌₂ⁿ₎ (tᵢ - 1)
7        j = j - 1                                c7        ∑₍ᵢ₌₂ⁿ₎ (tᵢ - 1)
8    A[j + 1] = key                               c8        n - 1 
```

알고리즘의 수행 시간은 각 명령문 수행 시간의 합이다. 즉 수행 시간이 ck 시간만큼 걸리는 명령문의 m번 실행된다면 총 수행 시간에 ck * m만큼 기여하게 된다.
최종적으로 n개의 원소에 대한 INSERTION-SORT의 수행 시간 T(n)을 구하기 위해 비용과 횟수를 곱을 합하면 다음과 같다.

```
T(n) = c1n + c2(n-1) + c4(n-1) + c5∑₍ᵢ₌₂ⁿ₎ tᵢ+...이하생략
```

입력의 크기가 정해진 경우라도 어떤 입력이 주어지느냐에 따라 알고리즘의 수행 시간은 변한다. 예를 들어 이 프로시저의 최선의 상황은 이미 배열이 정렬된 경우다.
이런 경우에는 5행에서 key는 A[i - 1]보다 항상 크거나 같을 것이다. 따라서 최선의 상황은 tᵢ는 1이 되어 수행시간은 다음과 같아진다.

```
T(n) = c1n + c2(n-1) + c4(n-1) + c5(n-1) + c8(n-1)
```

이 수행시간을 명령문의 비용 Ck에 의존하는 상수 a, b에 대한 an + b로 표현할 수 있다. 즉 n에 관한 **선형 함수**가 된다.

반면에 최악의 경우는 배열이 역순으로 정렬된 경우일 것이다. 이는 곧 각 A[i]를 정렬된 부분 배열 A[1: i - 1] 전부와 비교해야되므로, tᵢ는 i가 된다.

따라서 최악의 경우 INSERTION-SORT의 수행 시간은 다음이 된다.

```
T(n) = c1n + c2(n-1) + c4(n-1) c5(n(n+1)/2 -1) + c6(n(n-1)/2) + c7(n(n-1)/2) + c8(n-1) 
```

결국 최악의 경우 수행 시간을 an^2 + bn + c로 표현할 수 있으며 이때 상수 a, b, c는 명령문의 비용 ck에 의해 결정된다. 다시 말해 수행 시간은 n에 관한 **이차 함수**이다.

삽입 정렬의 경우처럼 일반적으로 입력이 주어지면 이에 대한 알고리즘의 수행 시간은 일정하다. 그러나 "랜덤화된" 알고리즘은 고정된 입력에 대해서도 동작이 달라질 수 있는데 이에 대해서는 뒤에서 살펴볼 것이다.


### 최악의 경우와 평균적인 경우의 분석

알고리즘에 따라 최선과 평균 그리고 최악이 존재하지만 해당 문서에서는 주로 `최악의 경우 수행 시간`에 관심을 가질 것이다. 이유는 다음과 같다.

- 알고리즘에서 최악의 경우 수행 시간이 모든 입력의 수행 시간에 대한 상한이 된다. 수행 시간에 대한 경험적인 추측이 필요 없어지고 더 이상 나빠지지 않기를 바랄 필요도 없다.
- 어떤 알고리즘은 최악의 경우가 상당히 빈번하게 발생할 수 있다. 예를 들어, 특정 정보를 데이터베이스에서 검색할 때 검색 알고리즘의 최악의 경우는 해당 정보가 데이터베이스에 없는 상황이다. 실제로 일부 응용 프로그램에서는 없는 정보를 검색하는 경우가 자주 발생한다.
- 이름만 평균일 뿐 거의 최악의 경우만큼 좋지 못한 상황일 때가 종종 있다. 우리가 다룬 삽입 정렬만 하더라도 평균적인 경우의 수행시간이 입력 크기에 관한 이차식이 되는데 이는 최악의 경우와 거의 차이가 없다.

반면 어떤 경우에는 평균 수행 시간이 중요하다. 앞으로 여러 알고리즘에서 적용할 확률적 분석 기법을 살펴보는데, 이를 통해 수행 시간의 평균값을 구할 수 있다. 그러나 문제에 대해 평균적인 경우를 분석할 때 무엇이 "평균적인" 입력인지 불확실한 경우가 있을 수 있다.
그래서 흔히 입력의 크기가 정해지면 가능한 모든 입력이 비슷한 정도로 나타난다고 가정한다. 현실에서 그러한 가정을 만족하지 못할 때는 `확률적 분석`이 이루어질 수 있도록 임의로 선택하는 `랜덤화된 알고리즘`을 사용해 기대 수행 시간을 구하기도 한다. 이는 나중에 다룰 것이다.


### 증가 차수

앞서 INSERTION-SORT 프로시저의 분석을 쉽게 하기 위해 몇 가지 단순한 개념을 이용했다. 각 명령문의 실제 비용을 무시하고 대신 상수 Ck로 표현했다. 또한 상수 a b c에 대해 최상의 경우 수행시간은 an + b로 표현했으며 최악의 경우는 an^2 + bn + c로 표현되는 것으로 충분했다.
이는 **실제 명령문의 비용을 무시할 뿐만 아니라 추상적인 비용 Ck도 고려하지 않는 것이다.**

좀 더 단순하게 추상화하여 수행 시간의 **증가 비율** 또는 **증가 차수**를 이용할 수 있는데, 이는 정말 중요하다. 식에서 충분히 큰 n에 대해 차수가 낮은 항이 상대적으로 덜 중요하므로 차수가 가장 높은 항만 고려할 것이다. 또한 가장 높은 항의 상수 계수도 무시하는데, 이것도 큰 입력의 효율성을 계산할 때 증가 비율에 비해 덜 중요하기 때문이다.
그러므로 삽입 정렬에서도 차수가 낮은 항과 차수가 가장 높은 항의 상수 계수를 무시하고 최고 차항의 n^2만을 남긴다. 가장 높은 차수의 항이 가장 중요한 부분이다.

수행 시간의 증가 순서를 강조하기 위해 그리스 문자 세타를 사용하는 특별한 표기법이 있다.(여기선 그냥 O로 표현한다) 삽입 정렬의 최악의 경우 실행 시간은 O(n^2)(N-제곱의 세타 또는 세타 N-제곱이라고 한다) 또한 삽입 정렬의 최선의 수행 시간은 O(n)(세타 n 또는 n의 세타)이라고 한다. 지금은 이러한 표기를 "n이 클 때 대략 비례" 라고 생각하면 된다.
이후에 이러한 표기를 정확하게 정의할 것이다.

일반적으로 어떤 알고리즘이 다른 알고리즘보다 최악의 경우 수행 시간이 더 낮은 증가 차수를 가질 때 더 효율적이라고 한다. 입력이 작은 경우에는 그러한 주장이 맞지 않을 수가 있으나, 입력의 크기가 충분히 큰 경우라면 타당하다.

## 알고리즘의 설계

알고리즘을 설계하는 방법은 여러 가지다. 삽입 정렬은 `점진적인` 방법을 사용한다. 즉 원소 A[i]를 정렬된 부분 배열 A[1 : i-1]의 적절한 위치에 삽입하여 다시 정렬된 부분 배열 A[1 : i]를 만든다.

이 절에서는 **분할 정복**으로 알려진 또 다른 방법론을 살펴보고 이 기법을 이용해 삽입 정렬의 최악의 경우 수행 시간보다 훨씬 빠른 정렬 알고리즘을 설계할 것이다.

### 분할 정복 접근법

`재귀적` 구조를 가진 유용한 알고리즘이 많다. 이 알고리즘에서는 주어진 문제를 풀기 위해 **자기 자신을 재귀적으로 여러 번 호출함**으로써 밀접하게 연관된 부분 문제를 다룬다. 이런 알고리즘들은 전형적으로 **분할 정복** 접근법을 따른다.
전체 문제를 원래 문제와 유사하지만 크기가 작은 몇 개의 부분 문제로 분할하고, 부분 문제를 재귀적으로 푼다. 그런 다음 찾은 해를 결합하여 원래 문제의 해를 만들어 낸다.

문제가 충분히 작은 경우에는 재귀 없이 바로 문제를 해결하면 된다. 그렇지 않은 경우에는 다음 세 가지 단계를 거치면서 재귀적으로 문제를 푼다.

- **분할** : 현재의 문제를 같은 문제를 다루는 다수의 부분 문제로 분할한다.
- **정복** : 부분 문제를 재귀적으로 풀어서 정복한다. 부분 문제의 크기가 충분히 작으면 직접적인 방법으로 푼다.
- **결합** : 부분 문제의 해를 결합하여 원래 문제의 해가 되도록 만든다.

**병합 정렬** 알고리즘은 분할 정복 방법을 따른다. 각 단계에서는 전체 배열 A[1:n]에서 시작하여 점점 더 작은 하위 배열로 내려가면서 하위 배열을 정렬한다. 병합 정렬은 다음과 같이 작동한다.
- 분할 : 정렬할 하위 배열 A[P:R]을 각각 절반 크기의 인접한 두 하위 배열로 나눈다. 이렇게 하려면 A[P:R]의 중간점 Q를 계산하고(P와 R의 평균을 취한다) 즉 하위 배열을 다시 더 나누어 하위 배열 A[P:Q]. A[Q+1:R]로 나눈다.
- 정복 : 병합 정렬을 사용하여 재귀적으로 두 개의 하위 배열을 각각 정렬한다.
- 결합 : 정렬된 두 개의 하위 배열을 다시 A[P:R]로 병합하여 정렬된 해를 구한다.

당연하지만 정렬할 수열의 크기가 1이 되면 그것은 이미 정렬된 것이므로 더는 할 일이 없어 재귀호출이 "하한에 이르게" 된다. 이는 INSERTION-SORT의 루프 불변성에 대한 초기화 인수에서 언급했듯이 단일 원소로만 구성된 하위 배열은 항상 정렬된다.

병합 정렬 알고리즘에서 핵심 작업은 "결합" 단계에서 정렬된 두 부분 배열을 병합하는 것이다. 이를 위해선 보조 프로시저 MERGE(A, P, Q, R)이 필요하다. A는 배열이고 P Q R은 익덱스로 P <= Q < R을 만족한다. 프로시저 MERGE는 두 부분 배열 A[p:q]와 A[q + 1 : r]이 정렬되어 있다고 가정하고 이를 병합해서 정렬된 배열 하나를 만드는데 이것이 원래의 부분배열을 대체한다.

MERGE 프로시저가 어떻게 작동하는지 이해하기 쉽게 카드로 다시 예를 들어보겠다. 탁자 위에 두 더미의 카드가 앞면이 보이도록 쌓여있는 것이다. 각 카드 더미는 정렬이 되어있고 가장 작은 카드 순으로 앞에 있다. 이제 두 카드 더미를 병합해 앞면이 보이는 새로운 카드 더미 하나를 만드려고 한다. 두 카드 더미 위에 있는 두 장의 카드 중 더 작은 것을 선택해 더미에서 골라내고 골라낸 카드를 앞면이 아래로 향하게 해서 더미 위에 놓는다. 이런 작업을 주어진 두 카드 더미 중 하나가 빌 때까지 반복한 후 아직 남아있는 카드 더미를 앞면이 아래로 향하게 하여 출력 카드 더미에 통째로 합치면 된다.

정렬된 카드 더미 두 개를 병합하는 데 걸리는 시간을 생각해 보자. 맨 위에 있는 두 장의 카드만 비교하기 때문에 각 기본 단계에는 상수 시간이 걸린다. 정렬된 두 더미에 각각 n/2장의 카드가 있다면, 기본 단계의 수는 최소 n/2에서 최대 n(실제로는 n - 1)이다. 각 기본 단계에 상수 시간이 걸리고 기본 단계의 총 개수가 n/2에서 n사이이므로 병합에 걸리는 시간은 대략 n에 비례한다고 말할 수 있다. 즉 병합에는 O(n) 시간이 걸린다.

```
MERGE(A, p, q ,r)
nl = q - p + 1 // A[p:q}의 크기
nr = r - q // A[q + 1 :r]의 크기
배열L[0:nl -1]과 R[0:nr -1]을 생성한다.
for i = 0 to nl - 1 // A[p:q}를 L[0:nl -1}로 복사
     L[i] = A[p + i]
for j = 0 to nr -1 // [q + 1 :r]을 R[0 : nr -1] 로 복사
     R[j] = A[q + j + 1]
i = 0 // i는 L에 남아있는 가장 작은 원소를 인덱싱
j = 0 // j는 R에 남아있는 가장 작은 원소를 인덱싱
k = p // k는 채울 A의 위치를 인덱싱
// 각 배열 L과 R에 병합되지 않은 원소가 포함되어 있으면 병합되지 않은 원소 중 가장 작은 원소를 A[p:r]로 다시 복사
while i < nl and j < nr
     if L[i]<= L[i]
          A[k] = L[i]
          i = i + 1
     else A[k] = R[j]
          j = j +1
     k = k + 1
// L과 R 중 하나를 완전히 살펴본 후 나머지 하나를 A[p:r]끝에 복사
while i < nl
     A[k] = L[i]
     i = i + 1
     k = k + 1
while i < nr
     A[k] = R[j]
     j = j + 1
     k = k + 1
```

MERGE 프로시저는 구체적으로 다음과 같이 작동한다. 두 개의 부분 배열 A[p:q]와 A[q + 1: r]을 임시 배열 L과 R에 복사한다음, L, R의 값을 다시 A[p:r]에 병합한다.
1. 1행과 2행에서 각각 부분배열의 크기들을 계산한다.
     - 이 예제에서는 1-원점 인덱싱과 0-원점 인덱싱을 모두 사용하는 드문 경우다
2. 그리고 3행에서 크기가 각각 nl과 nr인 배열 L[0:nl -1]과 R[0:nr-1]을 생성한다.
3. 4 ~ 5행의 for루프에서 부분 배열 A[p:q]를 L로 복사하고, 6~7행의 for 루프에서 부분 배열 A[q + 1:r]을 R로 복사한다.
4. 12 ~ 18행의 while 루프는 L과 R에서 아직 복사되지 않은 가장 작은 값을 반복적으로 식별하여 A[p:r]에 다시 복사한다.
     - 주석에서 알 수 있듯이 인덱스 k는 채워지고 있는 A의 위치를, 인덱스 i와 j는 각각 L과 R에서 남은 가장 작은값의 위치를 나타낸다.
     - 결국 L의 전체 또는 R의 전체가 A[p:r]에 다시 복사되고 이 루프가 종료된다.
     - R의 전부가 다시 복사되어 종료되는 경우, 즉 j가 nr과 같아서 루프가 종료되는 경우, i는 여전히 nl보다 작으므로 L의 일부가 아직 복사되지 않았고 이 값은 L과 R 전체에서 가장 크다.
     - 이 경우 20-23행의 while루프는 L의 이러한 나머지 값을 A[p:r]의 마지막 몇 위치에 복사한다.
5. j는 nr과 같으므로 24 ~ 27행의 while 루프는 0회 반복된다. 대신 12~18행의 while 루프가 i와 nl이 같아서 종료되면, L의 모든 값이 이미 A[p:r]로 다시 복사되고 24-27의 while 루프는 R의 나머지 값을 다시 A[p:r]의 끝으로 복사한다.

이제 MERGE 프로시저를 병합 정렬 알고리즘의 서브루틴으로 이용한다. MERGE-SORT(A, p, r)은 부분 배열 A[p:r]을 정렬하는 프로시저다.
만약 p와 r이 같다면 부분 배열이 많아야 원소 하나로 구성되므로 이미 정렬되었다고 말할 수 있다. 그렇지 않으면 p보다 r이 커야하며, MERGE-SORT는 분할, 정복, 결합 단계를 실행한다. 분할 단계에서 부분 배열을 두 개의 부분 배열, 즉 원소가 n/2보다 작거나 같은 최대의 정수만큼 원소가 들어있는 배열과 n/2보다 크거나 같은 최소의 정수만큼 원소가 들어있는 배열로 분할하기 위해 인덱스 q를 간단히 계산한다.

```
MERGE-SORT(A,p,r)
1 if p >= r // 0 또는 하나의 원소일 경우
2     return
3 q = (p + r)/2 보다 작거나 같은 최대 정수 // [p:r]의 중간점
4 MERGE-SORT(A, p, q) // A[p:q]를 재귀적으로 정렬
5 MERGE-SORT(A, q + 1, r) // A[q + 1: r]을 재귀적으로 정렬
6 // 위의 두 배열을 다시 A[p:r]로 병합한다.
7 MERGE(A, p, q, r)
```

만약 입력값 n이 2의 정확한 거듭제곱이 아닌 경우 일부 분할 단계에서는 크기가 1씩 다른 부분 배열을 만든다(예를 들어 크기 7의 부분배열을 나눌 떄 하나는 4 하나는 3). 병합되는 두 부분 배열의 크기에 관계없이 총 n개의 원소를 병합하는 데 걸리는 시간은 O(n)이다.

#### 실제 자바 코드 구현

1. MERGE 메서드
``` java
public void Merge(int[] A, int p, int q, int r) {
     int numLeft = q - p + 1;
     int numRight = r - q;

     int[] leftArray = new int[numLeft];
     int[] rightArray = new int[numRight];

     for(int i = 0; i < leftArray.length; i ++) {
          leftArray[i] = A[p + i];
     }
     for(int j = 0; j < rightArray.length; j++) {
          rightArray[j] = A[q + j + 1];
     }
     int i = 0;
     int j = 0;
     int k = p;

     while(i < numLeft && j < numRight) {
          if (leftArray[i] <= rightArray[j]) {
               A[k] = leftArray[i];
               i++;
          } else {
               A[k] = rightArray[j];
               j++;
          }
          k++;
     }
     while(i < numLeft) {
          A[k] = leftArray[i];
          i++;
          k++;
     }
      while(j < numRight) {
          A[k] = rightArray[j];
          j++;
          k++;
     }
}
```
2.Merge-Sort 메서드
```java
public void MergeSort(int[] A, int p, int r) {
     if (p >= r) return;
     int q = (p + r) /2;
     MergeSort(A, p, q);
     MergeSort(A, q+1, r);
     Merge(A, p, q, r);
}
```

### 분할 정복 알고리즘의 분석

알고리즘이 자기 자신을 호출하는 재귀호출을 할 경우 수행 시간을 재귀 방정식 또는 점화식으로 설명할 수 있는데, 이는 입력의 크기가 n인 문제에 대한 전체 수행 시간을 더 작은 크기의 입력에 대한 수행 시간으로 나타내는 것이다. 그러면 수학적 도구를 이용해 점화식을 풀고 알고리즘의 성능에 대한 한계를 구할 수 있다.

T(n)을 입력 크기가 n인 문제에 대한 수행시간이라고 하자. 문제 크기가 충분히 작은 경우, 즉 **어떤 상수 n0 > 0에 대해, n < n0일 때 해를 직접 구하면 상수 시간에 문제를 풀 수 있으며 이는 O(1)로 쓴다.
     - 상수 c가 O(1)이라고 할 때, 계수 1의 계수 c를 무시하는 것이다.
주어진 문제가 원래 문제의 1/b인 a개의 부분 문제로 분할된다고 가정할 때 이떄 크기가 n/b인 부분 문제에 T(n/b) 시간이 걸렸다면 a개의 문제를 해결하는 데는 a * T(n/b)의 시간이 걸린다. 문제를 분할하는데 D(n) 시간이 걸리고 부분 문제들의 해를 결합하여 원래 문제의 해를 만드는 데 C(n) 시간이 걸린다면, 다음 점화식을 얻을 수 있다.

``` scss
t(n) = { O(1), if n < n₀,
         D(n) + aT(n/b) + C(n), otherwise
       }
```

때때로 분할 단계의 n/b 크기가 정수가 아닌 경우가 있다. 예를 들어 MERGE-SORT 프로시저는 크기 n의 문제는 n/2 보다 작거나 같은 최대의 정수/ 크거나 같은 최소의 정수의 부분 문제로 나뉜다. 이 둘의 차이는 최대 1이며, 큰 n의 경우 n을 2로 나눈 효과보다 훨씬 작으므로 두 크기를 모두 n/2라고 부르겠다. 나중에 하한과 상한을 무시하는 이런 단순화가 일반적으로 분할 정복 반복에 대한 해의 증가 차수에 영향을 미치치 않음을 확인할 것이다.

채택할 또 다른 규칙으로 재귀의 베이스 케이스에 대한 진술 생략이다. 그 이유는 어떤 상수 n0 > 0에 대해 n < n0이면 베이스 케이스는 거의 항상 T(n) = O(1)이 되기 떄문이다.

#### 병합 정렬의 분석

n개의 수를 정렬하는 병합 정렬에서 최악의 경우 수행 시간 T(n)에 관한 점화식을 다음과 같이 추론해 볼 수 있다.

- 분할 : 부분 배열의 중간 위치를 계산하므로 상수 시간이 걸린다. 즉 D(n) = 0(1)이다.(작업 시간이 입력 크기 n에 비례하지 않는다. 배열의 인덱스 검색은 덧셈과 나누기만 하면 된다.)
- 정복 : 두 개의 부분 문제를 재귀적으로 푸는데, 각 부분 문제는 크기가 n/2이므로 2T(n/2) 수행 시간이 걸린다.
- 결합 : 이미 설명했듯이 n개의 원소에 대해 MERGE 프로시저는 O(n) 시간이 걸린다. 즉 C(n) = O(n)이다.

여기서 D(n)에다가 C(n)을 더하는건 O(n) 함수와 O(1) 함수를 더하는것과 같다. 이 두 함수의 합은 n의 선형 함수, 즉 O(n)이다. 정복 단계까지 더하면 병합 정렬의 최악의 경우 수행시간에 대한 점화식은 다음과 같다.

```
T(n) = 2T(n/2) + O(n)
```

향후 배우는 "마스터 정리"에 따르면 이 경우 T(n) = O(n lg n)이며 여기서 병합 정렬은 n의 계수를 lg n으로 나타낸다. 충분히 큰 입력에 대해 최악의 경우 수행 시간이 n lg n인 병합정렬이 n^2인 삽입 정렬보다 성능이 훨씬 좋다.

마스터 정리를 이용하지 않고 해당 점화식의 해가 T(n) = O(n lg n)이 되는 이유를 직관적으로 이해해보자. 단순화하기 위해 n이 2의 정확한 거듭제곱이고, 베이스 케이스는 n=1이라고 가정한다. 여기서 점화식을 다음과 같이 재작성해보자.

``` scss
T(n) = { C1                    if n =1
         2T(n/2) + C2n,        if n > 1
       }
여기서 상수 c1은 크기 1의 문제를 푸는데 필요한 시간, c2는 나누기 및 결합 단계의 배열 원소당 시간이다.
```

루트를 C2n으로 가지는 트리가 있다고 가정해보자. 루트에서 나뉜 두 하위 트리는 두 개의 더 작은 점화식 T(n/2)을 나타낸다. 여기서 더 한 단계 진행하여 두 번째 레벨에 있는 두 노드의 비용을 C2n/2라고 생각했을 때, 여기서 나누어진 하위 트리는 더 작은 점화식 T(n/4)로 나뉠 것이다.

각 노드를 이런 방식으로 쪼개어 트리를 계속 확장해, 문제의 크기가 1이 되어 비용이 C1이 될떄까지 분할한다. 다음으로 트리의 각 레벨에 비용을 더한다. 최상위 레벨은 총 비용 C2n, 그 다음 레벨은 C2n/2 + C2n/2 = C2n 식으로 계산한다. 각 레벨에는 상위레벨보다 2배 많은 노드가 있지만, 각 노드는 상위 레벨의 노드 비용의 절반만 기여한다.
즉 각 레벨의 비용은 C2n으로 동일해진다.

일반적으로 최상위 레벨보다 i단계 아래에 있는 레벨에는 각각 C2(n/2^i)의 비용을 기여하는 2^i 만큼의 노드가 있으므로 이를 정리하여 루트 레벨보다 i번째 레벨의 총 비용은
2^i * C2(n/2^) = C2n이 된다. 최하위 레벨에는 각각 C1의 비용이 기여하는 n개의 노드가 있으며 총 비용은, C1 * n이다.

재귀 트리의 총 레벨 수는 몇일까? 이런 사실은 간단한 귀납적 설명으로 쉽게 이해할 수 있다. 베이스 케이스인 n = 1일때는 레벨은 오직 하나이다. lg 1 = 0 이므로, lg n +1은 올바른 레벨 수다. 이제 2^i 개의 노드에 대한 재귀 트리의 레벨 수는 lg2^i +1 = i + 1이라는 가설이 성립한다고 가정하자.(임의의 i에 대해 lg2^i = i다.) 사전에 원래의 입력 크기는 2의 거듭제곱이라 가정했으므로 고려할 다음 입력 크기는 2^i+1이다. 리프가 n = 2^i+1인 트리는 리프가 2^i개인 트리보다 한 레벨을 더 가지므로  총 레벨 수는 (i + 1) + 1 = lg2^(i+1) + 1 이다.

이제 총 비용을 계산하려면 모든 레벨의 비용을 더하면 된다. lg n + 1 레벨이 있고 리프 위의 레벨은 각각 C2n의 비용이 든다. 리프 레벨은 C1n의 비용이 들므로 총 비용은
`C2n * lg n + C1n = O(n lg n)이다.`
