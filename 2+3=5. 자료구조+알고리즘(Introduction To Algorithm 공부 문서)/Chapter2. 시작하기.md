# 개요

알고리즘을 설계하고 분석하기 위해 이 책 전반에 걸쳐 사용하는 체계를 알아본다.
현재 해당 문서에서 서술된 내용을 이해하는데 필요한 내용을 대부분 담아보려고 한다. 다만 일부는 다른 문서에서 추가로 소개할 것이다.

시작은 이전 문서에서 소개한 삽입 정렬을 살펴보는 것으로 이 장을 시작한다. 전체 문서의 바탕이 되는 Introduction To Algorithm 교재에서는 알고리즘을 서술하기 위해  "의사코드"를 정의하여 이용한다. 아마 프로그래밍 언어 중 하나라도 익숙한 사람이라면 이해하기 쉬울 것이다.

삽입 정렬 알고리즘을 의사코드로 먼저 서술 후 그 알고리즘이 올바르게 정렬하는지 확인한다.
그리고 알고리즘의 수행 시간을 분석하는데, 이를 위해 정렬 대상 개수의 증가에 따른 수행 시간의 변화를 표현할 수 있는 표기법을 도입한다.
끝으로 삽입 정렬에 대해 더 자세히 알아보고, 알고리즘 설계 방법 중 하나인 분할 정복에 대한 소개와 이를 이용한 병합 정렬 알고리즘을 살펴보고 수행시간까지 분석하는 것으로 이 문서는 끝난다.


## 삽입 정렬

이전 문서에서 소개한 정렬 문제를 풀기 위해 문제를 다음과 같이 정의해본다.

```

```




```java
public void InsertionSort(Key[] A) {
  int n = A.length;
  for(int i = 1; i < n; i++) {
    Key key = A[i]; 
    int j = i -1;
    while(j >= 0 && A[j] > key) {
      A[j + 1] = A[j];
      j = j -1;
    }
    A[j + 1] = key;
  }
}
```

```java
public int SumArray(int[] a) {
  int sum = 0;
  for(int i = 0; i < a.length; i++) {
    sum += a[i]
  }
  return sum;
}
```

```java
//배열은 똑같이 5 2 4 6 1 3이라 가정하고  6 5 4 3 2 1로 만들어야함
public InsertionSort(Key[] a);
  for(int i = 1; i < a.length; i++) {
    Key key = a[i];
    int j = i - 1;
    while(j >= 0 && a[j] < key) {
      a[j + 1] = a[j];
      j = j - 1;
    }
    a[j + 1] = key;
  }
```

루프 불변성

초기화 : 루프가 첫 번째 반복을 시작하기 전에 참이다.
유지 : 루프의 반복이 시작되기 전에 참이면 다음 반복이 시작되기 전에도 참이 유지된다.
종료 : 루프가 종료될 때 그 불변식이 알고리즘의 타당성을 보이는 데 유용한 특성을 가져야 한다.

```
SUM-ARRAY(A, n)
1 sum = 0
2 for i = 1 to n
3   sum = sum + A[i]
4 return sum
```

초기화 : i가 1에서 시작할 때를 참인가를 묻는다. 여기서 불변 법칙은 A라는 배열에서 A[1:i]의 합이 리턴되느냐를 따짐.
A[0] 하나의값만이 있고 자기 자신과 아무것도 없는 걸 더해야하므로(0) 현재 A[0:i]의 합이 리턴되기에 루프 불변성이 유지된다.

유지 : 현재 for문에서 배열의 인덱스를 순차적으로 늘려가며 탐색중이고 해당 인덱스에 해당되는 값을 sum에다가 더한다. 즉 i -1, i-2, i-3..의 값이 sum에 누적되면서 더해지고 있다.
루프 불변성이 유지된다.

종료: 최종적으로 이 루프는 n + 1일때 종료되어 리턴한다. 현 루프에서 n + 1을 넣으면 이미 n을 넣었을때의 누적된 값이 sum에 더해져있는 상태로 리턴되므로 루프 불변성이 유지된다.
