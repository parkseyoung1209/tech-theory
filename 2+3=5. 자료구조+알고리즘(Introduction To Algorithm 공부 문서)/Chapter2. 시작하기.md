# 개요

알고리즘을 설계하고 분석하기 위해 이 책 전반에 걸쳐 사용하는 체계를 알아본다.
현재 해당 문서에서 서술된 내용을 이해하는데 필요한 내용을 대부분 담아보려고 한다. 다만 일부는 다른 문서에서 추가로 소개할 것이다.

시작은 이전 문서에서 소개한 삽입 정렬을 살펴보는 것으로 이 장을 시작한다. 전체 문서의 바탕이 되는 Introduction To Algorithm 교재에서는 알고리즘을 서술하기 위해  "의사코드"를 정의하여 이용한다. 아마 프로그래밍 언어 중 하나라도 익숙한 사람이라면 이해하기 쉬울 것이다.

삽입 정렬 알고리즘을 의사코드로 먼저 서술 후 그 알고리즘이 올바르게 정렬하는지 확인한다.
그리고 알고리즘의 수행 시간을 분석하는데, 이를 위해 정렬 대상 개수의 증가에 따른 수행 시간의 변화를 표현할 수 있는 표기법을 도입한다.
끝으로 삽입 정렬에 대해 더 자세히 알아보고, 알고리즘 설계 방법 중 하나인 분할 정복에 대한 소개와 이를 이용한 병합 정렬 알고리즘을 살펴보고 수행시간까지 분석하는 것으로 이 문서는 끝난다.


## 삽입 정렬

이전 문서에서 소개한 정렬 문제를 풀기 위해 문제를 다음과 같이 정의해본다.

```
입력 : n개 수들의 수열(a₁, a₂, ..., aₙ)
출력 : a'₁ ≤ a'₂ ≤ a'₃,... ≤ a'ₙ 을 만족하는 입력 수열의 순열(재배치) (a'₁, a'₂,... a'ₙ )
```

정렬할 숫자는 키(key)라고도 한다. 개념적으로는 수열을 정렬하는 문제이지만, 입력은 n개의 원소가 있는 배열의 형태로 제공된다. 숫자를 정렬하려는 경우, 숫자가 다른 데이터와 연관된 키인 경우가 많은데, 이를 **부속 데이터**라고 한다.
키와 부속 데이터는 하나의 **레코드**를 형성한다. 정렬 알고리즘을 설명할 때는 키에 초점을 맞추지만, 일반적으로 연관된 부속 데이터가 있다는 점을 기억하는 것이 중요하다.

- 심플하게 생각해보자. 프로그래머 입장에서 중요한 것은 단순히 숫자를 배열하는 것이 아니라, 레코드의 키 값을 기준으로 정렬하면서 부속 데이터가 해당 키와 올바르게 대응되도록 보장하는 것이다.
- 만약 자바 객체가 있고, 특정 필드만 정렬된 후 정렬된 필드 값을 기준으로 조회했을 때 부속 데이터가 엉뚱한 값을 반환한다면 이는 명백한 오류이다.(물론 객체로 만들었다는 것 자체가 이런 일이 일어나기가 어렵다..)

재차 말하지만 해당 문서를 포함한 전체 문서는 알고리즘을 **의사코드**로 표현한다. 여타 다른 프로그래밍 언어를 접해보았다면 어렵지 않게 이해할 수 있을 것이다.
- 의사코드와 실제 프로그램 코드의 차이는, 의사코드에서는 알고리즘을 명확하고 간결하게 서술할 수만 있다면, 어떤 표현 방법을 사용해도 좋다는 것이다.
- 예를 들어 어떤 경우에는 한글로 문장으로 서술하는게 제일 간결한 표현일 수도 있다.
- 또한 소프트웨어 공학 관점의 문제는 고려하지 않는데, 이는 곧 오류 처리 같은 문제는 무시될 수 있다는 것이다.

이제 크기가 작은 정렬에 효율적인 **삽입 정렬** 알고리즘으로 시작해보자.

삽입 정렬은 아마 사람이 실제로 어떠한 숫자를 정렬할 때 사용하는 방식과 가장 흡사한 방법이 아닌가싶다. 숫자가 쓰여져있는 카드 뭉치를 떠올려보자. 왼손은 비어있고 뒤집힌 카드 뭉치에서 카드를 한 장씩 가져와 왼손에다가 말 그대로 삽입하여 가져오는 것이다. 여기서 카드를 숫자 크기대로 정렬하겠다고 오른쪽에서 왼쪽 방향으로 새로운 카드를 기존 카드들과 쭉 비교하면 끝이다.

이런식이면 왼쪽에 있는 카드들은 항상 정렬되어 있을 것이다. 이 카드들은 처음 카드 뭉치에 있던 맨 위에 있던 카드들이다.

삽입 정렬을 위한 의사코드는 INSERTION-SORT 프로시저로 나와있다. 이 프로시저에는 두 개의 매개변수, 즉 정렬할 값을 포함하는 배열 A와 정렬할 값의 개수 n이 필요하다.
값은 배열의 A[1]에서 A[n]까지의 위치를 차지하며, 이를 A[1:n]으로 표시한다. INSERTION-SORT 프로시저가 완료되면 배열 A[1:n]에는 원래 값이 정렬된 순서대로 포함된다.

```java
public void InsertionSort(Key[] A) {
  int n = A.length;
  for(int i = 1; i < n; i++) {
    Key key = A[i]; 
    int j = i -1;
    while(j >= 0 && A[j] > key) {
      A[j + 1] = A[j];
      j = j -1;
    }
    A[j + 1] = key;
  }
}
```

```java
public int SumArray(int[] a) {
  int sum = 0;
  for(int i = 0; i < a.length; i++) {
    sum += a[i]
  }
  return sum;
}
```

```java
//배열은 똑같이 5 2 4 6 1 3이라 가정하고  6 5 4 3 2 1로 만들어야함
public InsertionSort(Key[] a);
  for(int i = 1; i < a.length; i++) {
    Key key = a[i];
    int j = i - 1;
    while(j >= 0 && a[j] < key) {
      a[j + 1] = a[j];
      j = j - 1;
    }
    a[j + 1] = key;
  }
```

루프 불변성

초기화 : 루프가 첫 번째 반복을 시작하기 전에 참이다.
유지 : 루프의 반복이 시작되기 전에 참이면 다음 반복이 시작되기 전에도 참이 유지된다.
종료 : 루프가 종료될 때 그 불변식이 알고리즘의 타당성을 보이는 데 유용한 특성을 가져야 한다.

```
SUM-ARRAY(A, n)
1 sum = 0
2 for i = 1 to n
3   sum = sum + A[i]
4 return sum
```

초기화 : i가 1에서 시작할 때를 참인가를 묻는다. 여기서 불변 법칙은 A라는 배열에서 A[1:i]의 합이 리턴되느냐를 따짐.
A[0] 하나의값만이 있고 자기 자신과 아무것도 없는 걸 더해야하므로(0) 현재 A[0:i]의 합이 리턴되기에 루프 불변성이 유지된다.

유지 : 현재 for문에서 배열의 인덱스를 순차적으로 늘려가며 탐색중이고 해당 인덱스에 해당되는 값을 sum에다가 더한다. 즉 i -1, i-2, i-3..의 값이 sum에 누적되면서 더해지고 있다.
루프 불변성이 유지된다.

종료: 최종적으로 이 루프는 n + 1일때 종료되어 리턴한다. 현 루프에서 n + 1을 넣으면 이미 n을 넣었을때의 누적된 값이 sum에 더해져있는 상태로 리턴되므로 루프 불변성이 유지된다.
