# 개요

알고리즘을 설계하고 분석하기 위해 이 책 전반에 걸쳐 사용하는 체계를 알아본다.
현재 해당 문서에서 서술된 내용을 이해하는데 필요한 내용을 대부분 담아보려고 한다. 다만 일부는 다른 문서에서 추가로 소개할 것이다.

시작은 이전 문서에서 소개한 삽입 정렬을 살펴보는 것으로 이 장을 시작한다. 전체 문서의 바탕이 되는 Introduction To Algorithm 교재에서는 알고리즘을 서술하기 위해  "의사코드"를 정의하여 이용한다. 아마 프로그래밍 언어 중 하나라도 익숙한 사람이라면 이해하기 쉬울 것이다.

삽입 정렬 알고리즘을 의사코드로 먼저 서술 후 그 알고리즘이 올바르게 정렬하는지 확인한다.
그리고 알고리즘의 수행 시간을 분석하는데, 이를 위해 정렬 대상 개수의 증가에 따른 수행 시간의 변화를 표현할 수 있는 표기법을 도입한다.
끝으로 삽입 정렬에 대해 더 자세히 알아보고, 알고리즘 설계 방법 중 하나인 분할 정복에 대한 소개와 이를 이용한 병합 정렬 알고리즘을 살펴보고 수행시간까지 분석하는 것으로 이 문서는 끝난다.


## 삽입 정렬

이전 문서에서 소개한 정렬 문제를 풀기 위해 문제를 다음과 같이 정의해본다.

```
입력 : n개 수들의 수열(a₁, a₂, ..., aₙ)
출력 : a'₁ ≤ a'₂ ≤ a'₃,... ≤ a'ₙ 을 만족하는 입력 수열의 순열(재배치) (a'₁, a'₂,... a'ₙ )
```

정렬할 숫자는 키(key)라고도 한다. 개념적으로는 수열을 정렬하는 문제이지만, 입력은 n개의 원소가 있는 배열의 형태로 제공된다. 숫자를 정렬하려는 경우, 숫자가 다른 데이터와 연관된 키인 경우가 많은데, 이를 **부속 데이터**라고 한다.
키와 부속 데이터는 하나의 **레코드**를 형성한다. 정렬 알고리즘을 설명할 때는 키에 초점을 맞추지만, 일반적으로 연관된 부속 데이터가 있다는 점을 기억하는 것이 중요하다.

- 심플하게 생각해보자. 프로그래머 입장에서 중요한 것은 단순히 숫자를 배열하는 것이 아니라, 레코드의 키 값을 기준으로 정렬하면서 부속 데이터가 해당 키와 올바르게 대응되도록 보장하는 것이다.
- 만약 자바 객체가 있고, 특정 필드만 정렬된 후 정렬된 필드 값을 기준으로 조회했을 때 부속 데이터가 엉뚱한 값을 반환한다면 이는 명백한 오류이다.(물론 객체로 만들었다는 것 자체가 이런 일이 일어나기가 어렵다..)

재차 말하지만 해당 문서를 포함한 전체 문서는 알고리즘을 **의사코드**로 표현한다. 여타 다른 프로그래밍 언어를 접해보았다면 어렵지 않게 이해할 수 있을 것이다.
- 의사코드와 실제 프로그램 코드의 차이는, 의사코드에서는 알고리즘을 명확하고 간결하게 서술할 수만 있다면, 어떤 표현 방법을 사용해도 좋다는 것이다.
- 예를 들어 어떤 경우에는 한글로 문장으로 서술하는게 제일 간결한 표현일 수도 있다.
- 또한 소프트웨어 공학 관점의 문제는 고려하지 않는데, 이는 곧 오류 처리 같은 문제는 무시될 수 있다는 것이다.

이제 크기가 작은 정렬에 효율적인 **삽입 정렬** 알고리즘으로 시작해보자.

삽입 정렬은 아마 사람이 실제로 어떠한 숫자를 정렬할 때 사용하는 방식과 가장 흡사한 방법이 아닌가싶다. 숫자가 쓰여져있는 카드 뭉치를 떠올려보자. 왼손은 비어있고 뒤집힌 카드 뭉치에서 카드를 한 장씩 가져와 왼손에다가 말 그대로 삽입하여 가져오는 것이다. 여기서 카드를 숫자 크기대로 정렬하겠다고 오른쪽에서 왼쪽 방향으로 새로운 카드를 기존 카드들과 쭉 비교하면 끝이다.

이런식이면 왼쪽에 있는 카드들은 항상 정렬되어 있을 것이다. 이 카드들은 처음 카드 뭉치에 있던 맨 위에 있던 카드들이다.

삽입 정렬을 위한 의사코드는 INSERTION-SORT 프로시저로 나와있다. 이 프로시저에는 두 개의 매개변수, 즉 정렬할 값을 포함하는 배열 A와 정렬할 값의 개수 n이 필요하다.
값은 배열의 A[1]에서 A[n]까지의 위치를 차지하며, 이를 A[1:n]으로 표시한다. INSERTION-SORT 프로시저가 완료되면 배열 A[1:n]에는 원래 값이 정렬된 순서대로 포함된다.

```
INSERTION-SORT(A, n)
1  for i = 2 to n
2    key = A[i]
3    // A[i]를 정렬된 배열 A[1:i-1]에 삽입한다.
4    j = i - 1
5    while j > 0 and A[j] > key
6        A[j + 1] = A[j]
7        j = j - 1
8    A[j + 1] = key
```

### 루프 불변성과 삽입 정렬의 타당성

인덱스 i는 왼손으로 가져가 정렬할 "현재 카드"를 나타낸다. for 루프에서 인덱스 i로 표시되는 반복이 시작될 때 **부분 배열** A[1:i-1]은 현재 손에 쥔 정렬된 카드이고 나머지 부분 배열 A[i + 1 : n]은 아직 탁자에 있는 카드더미이다. 즉 A[1:i-1]은 처음에 탁자에 쌓인 순서대로 맨 앞부터 i - 1번째까지의 값이지만 이제는 정렬되어 저장된 것이다. 해당 배열의 이런 특성을 엄밀하게 표현하면 **루프 불변성이라 한다.**

     좀 더 명확히 말하자면 루프 불변성이란 루프가 반복될 때마다 항상 참으로 유지되는 조건을 의미한다.
 
해당 프로시저의 루프 불변성
- **1~8행의 부분 배열 A[1:i-1]은 루프가 반복을 시작할 때마다 원래 A[1:i-1] 원소로 정렬된 순서로 구성된다.**

루프 불변성은 알고리즘이 타당한 이유를 쉽게 이해할 수 있도록 하기 위해 사용된다. 루프 불변성을 보이려면 다음 세 가지 특성을 만족해야 한다.

1. 초기화 : 루프가 첫 번째 반복을 시작하기 전에 참이다.
2. 유지 : 루프의 반복이 시작되기 전에 참이면 다음 반복이 시작되기 전에도 참이 유지된다.
3. 종료 : 루프가 종료될 때 그 불변식이 알고리즘의 타당성을 보이는 데 유용한 특성을 가져야 한다.

해당 조건의 1, 2번을 만족하면 루프가 시작할 때 루프 불변성은 항상 참이다. 여기서 유의해야할 점은 **매 루프를 시작하기 전에 루프 불변성이 유지됨을 보이기 위해 루프 불변성이 아닌 다른 사실을 이용해도 된다는 점이다.** 좀 더 명확히 말하자면, 루프 불변성을 유지하기 위해, 반드시 불변 조건(루프 불변성)만을 직접적으로 활용할 필요는 없고, 루프가 어떻게 작동하는지에 대한 다른 논리적 특성이나 외부의 맥락적 정보를 활용해도 괜찮다는 점이다.

3번 특성이 가장 중요한데, 결국 루프 불변성을 보이는 목적이 알고리즘의 타당성을 보이는 것이기 때문이다. 보통 루프의 종료 조건이 완료될 때까지 루프 불변성을 이용한다.
실제 수학에서 사용되는 일반적인 수학적 귀납법은 귀납적 과정이 무한히 반복되는데 반해 여기서는 루프가 종료될 때 귀납적 과정도 끝난다.

이제 삽입 정렬 알고리즘에서 이런 특성이 어떻게 만족되는지 살펴보자.

- **초기화** : 먼저 루프의 첫 반복이 시작되기 전, 즉 i = 2일 때 루프 불변성이 성립하는지를 살펴본다. 이때 부분 배열 A[1: i - 1]은 A[1] 한 개의 원소로 구성되는데, 애시당초 A[1]의 값 하나밖에 없다. 해당 부분 배열은 당연히 정렬되어 있으므로 루프의 반복 시작 전에 루프 불연성이 성립한다.

- **유지** : 다음으로 매 반복 시 루프 불변성이 유지되는지 살펴본다. 간단히 설명하면 for 루프의 바디 부분은 A[i]의 올바른 위치를 찾을 때까지 A[i - 1], A[i - 2], A[i - 3]을 오른쪽으로 한 자리씩 이동시키는 작업응 한 뒤(4~7)행 값을 적절한 위치에 삽입한다(8행). 그러면 배열은 기존 배열과 동일한 원소를 정렬한 상태로 갖게 된다. i가 1씩 증가하면서 for 루프의 다음 반복에서 루프 불변성이 유지된다.

- **종료** : 마지막으로, 루프가 종료되었을 때 어떤 상황이 발생하는지를 조사해본다. 삽입 정렬의 경우 for 루프는 i가 n보다 커질 때 종료한다. 루프 불변성에서 i에 n + 1을 대입하면 부분 배열 A[1 : n]은 원래 배열에 있는 원소들로 정렬한 순서대로 구성된다. 따라서 알고리즘은 타당하다. 


#### 의사코드 기반으로 짜본 자바 삽입 정렬

1. 기존
```java
public void InsertionSort(Key[] A) {
  int n = A.length;
  for(int i = 1; i < n; i++) {
    Key key = A[i]; 
    int j = i -1;
    while(j >= 0 && A[j] > key) {
      A[j + 1] = A[j];
      j = j -1;
    }
    A[j + 1] = key;
  }
}
```

2. 내림차순
```java
//배열은 똑같이 5 2 4 6 1 3이라 가정하고  6 5 4 3 2 1로 만들어야함
public InsertionSort(Key[] a);
  for(int i = 1; i < a.length; i++) {
    Key key = a[i];
    int j = i - 1;
    while(j >= 0 && a[j] < key) {
      a[j + 1] = a[j];
      j = j - 1;
    }
    a[j + 1] = key;
  }
//달라진건 오직 while문의 비교 연산밖에 없다
```

#### 연습문제

2번

```
SUM-ARRAY(A, n)
1 sum = 0
2 for i = 1 to n
3   sum = sum + A[i]
4 return sum
```


초기화 : i가 1에서 시작할 때를 참인가를 묻는다. 여기서 불변 법칙은 A라는 배열에서 A[1:i]의 합이 리턴되느냐를 따짐.
A[0] 하나의값만이 있고 자기 자신과 아무것도 없는 걸 더해야하므로(0) 현재 A[0:i]의 합이 리턴되기에 루프 불변성이 유지된다.

유지 : 현재 for문에서 배열의 인덱스를 순차적으로 늘려가며 탐색중이고 해당 인덱스에 해당되는 값을 sum에다가 더한다. 즉 i -1, i-2, i-3..의 값이 sum에 누적되면서 더해지고 있다.
루프 불변성이 유지된다.

종료: 최종적으로 이 루프는 n + 1일때 종료되어 리턴한다. 현 루프에서 n + 1을 넣으면 이미 n을 넣었을때의 누적된 값이 sum에 더해져있는 상태로 리턴되므로 루프 불변성이 유지된다.

3번

```
INSERTION-SORT(A, n)
1  for i = 2 to n
2    key = A[i]
3    // A[i]를 정렬된 배열 A[1:i-1]에 삽입한다.
4    j = i - 1
5    while j > 0 and A[j] < key
6        A[j + 1] = A[j]
7        j = j - 1
8    A[j + 1] = key
```


## 알고리즘의 분석

알고리즘의 분석은 그 알고리즘을 실행하는 데 필요한 자원을 에측하는 것을 의미한다. 대부분의 경우에 측정 대상은 계산 시간이다. 일반적으로 어떤 문제를 해결할 수 있는 알고리즘이 여러 개이면 이를 분석하여 가장 효율적인 알고리즘을 쉽게 구분할 수 있다.

분석에 앞서 구현 기술의 모델을 잘 정의해야 하는데, 여기에는 그 기술에 필요한 자원과 비용에 관한 모델도 포함된다. 이 책에서는 대부분의 경우, 알고리즘이 단일 프로세서와 **RAM**(Random Access Machine, 랜덤 접근 기계) 모델에서 컴퓨터 프로그램으로 구현된다고 가정한다.
     - RAM 모델에서는 명령어는 동시에 수행되지 않고 차례로 하나씩 실행된다.
     - 변수값을 사용하거나 변수에 저장하는 것은 다른 데이터 접근과 동일한 시간이 걸린다.
     - 즉 RAM 모델에서는 각 명령어 또는 데이터 접ㄱ은에 상수 시간이 걸리며, 심지어 배열로 인덱시앟는 경우에도 마찬가지이다.
엄밀하게는 RAM 모델에서의 명령어와 비용도 정확하게 정의해야 한다. 그러나 이는 실제 알고리즘 배움에 있어 그다지 도움이 되지는 못한다. 물론 실제 컴퓨터가 어떤 식으로 설계되어 있는지를 충분히 참고해야한다.

RAM 모델에서 데이터 형은 정수와 부동소수이다. **실제 컴퓨터에는 일반적으로 Bool값 true와 false에 대한 별도의 데이터 유형이 없다.**
