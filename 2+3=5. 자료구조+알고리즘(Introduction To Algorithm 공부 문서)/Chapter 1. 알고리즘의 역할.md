# 알고리즘의 역할

알고리즘이란 무엇인가, 알고리즘은 왜 연구할 가치가 있는 것일까, 컴퓨터 분야에서 이용되고 다른 기술과 관련해 알고리즘은 어떤 역할을 할까? 이 챕터에서는 이런 질문에 대한 답을 찾아본다.

## 알고리즘

알고리즘(Algorithm)은 간단히 말해 어떤 값이나 값의 집합을 입력으로 받아, 또 다른 값이나 값의 집합으로 출력하는 잘 정의된 계산 절차를 의미한다.
따라서 알고리즘은 어떠한 입력을 출력으로 변환하는 일련의 계산 작업이라고 할 수 있다.

또한 알고리즘을 잘 정의된 계산 문제를 풀기 위한 도구로도 볼 수 있다. 계산문제를 정의하려면 **입력과 출력의 관계를 잘 서술해야하는데** 알고리즘이 이러한 입력과 출력의 관계를 구현할 수 있는 계산 과정을 설명한다.

예를 들어, 주어진 숫자들을 오름차순(작은 것에서 큰 순서)으로 정렬한다고 해보자. 이런 정렬 문제를 다음과 같이 정의할 수 있다.

```
입력 : n개 수들의 수열(a₁, a₂, ..., aₙ)
출력 : a'₁ ≤ a'₂ ≤ a'₃,... ≤ a'ₙ 을 만족하는 입력 수열의 순열(재배치) (a'₁, a'₂,... a'ₙ )

*첨자(a₁, a₂, ..., aₙ에 붙은 작은 숫자)*
현재 입력값에 쓰인 작은 숫자들을 첨자라고 부르는데, 일반적으로 동일한 이름의 변수에 대해 순서를 나타내거나, 변수의 다양한 구성요소를 나타낼 때 사용한다.

*프라임(Prime, ′)*
Prime(프라임)은 보통 작은 기호를 사용하여 기존 변수의 변형을 나타낸다.
여기선 기존 a₁, a₂, ..., aₙ의 수정된 값을 의미한다.
```

여기서 (31, 2 ,29 ,45 ,17, 13) 이라는 수열이 주어지면 정렬 알고리즘은 수열 (2, 13, 17, 29, 31, 45)를 출력한다. 그리고 이런 입력 수열을 정렬 문제의 `사례(instance)` 라고 한다.
일반적으로 어떤 문제의 사례는 그 문제의 해를 계산하기 위해 필요한 입력으로 구성되며 문제의 정의에서 요구하는 입력에 대한 제약조건을 만족해야 한다.
- 때로는 문제 맥락을 알 수 있을 때 문제 사례 자체를 단순히 "문제"라고 부르기도 한다.
- 해당 문장을 좀 더 간단히 이해할 수 있는 실제 예시를 들자면, 주어진 조건에 따라 어떠한 버스의 좌석에 승객들을 배치시켜보는 것이다.
  - 버스 좌석 배정 문제를 해결하기 위해서는 승객 수 20명과 좌석 수 40개라는 입력이 주어진다.
  - 이때, 한 좌석에는 최대 한 명의 승객만 앉을 수 있다는 제약조건이 있다. 이 문제의 해는 20명의 승객이 각기 다른 20개의 좌석에 앉는 것이다.

많은 프로그램에서 중간 과정으로 사용하는 정렬은 컴퓨터 과학에서 중요한 작업이기에, 이미 좋은 알고리즘들이 많이 개발되었다.
여기서 "어떤 알고리즘이 가장 좋은가"는 정렬할 대상이 몇개인지, 이미 어느 정도까지 정렬되어있는지, 대상의 값에 어떠한 제약조건이 있으며, 심지어 컴퓨터 구조나 이용되는 저장장치가 무엇인지에 따라 달라진다.

알고리즘이 모든 입력 사례에 대해 항상 올바른 출력을 내고 종료할 경우 이를 **타당하다**고 하며, 그 타당한 알고리즘이 주어진 계산 문제를 **푼다**라고 말한다.

타당하지 않은 알고리즘은 모든 또는 일부 입력 사례에서 종료되지 않거나, 올바르지 않은 답을 도출하며 종료할 것이다. 그러나 이러한 **타당하지 않은 알고리즘도 오류를 조절할 수 있으면** 유용할 때가 있다. 
(이와 관련된 예는 매우 큰 소수를 찾는 알고리즘을 다룰 떄 살펴볼 수 있다.)


### 어떤 문제를 알고리즘으로 푸는가

알고리즘의 실용적인 응용은 다양한 곳에서 찾아볼 수 있으며, 그중 몇 가지 예는 다음과 같다.

- 인터넷은 세계 각지의 사람이 빠르게 접근하여 엄청난 양의 정보를 검색할 수 있게 해준다. 특정 정보가 있는 페이지를 빨리 검색하는 문제라던가, 데이터가 전송될 좋은 경로를 찾는 문제 등 우수한 알고리즘들이 있다.
- 전자상거래는 상품과 서비스를 전자적으로 합의하고 교환할 수 있게 해준다. 이는 신용카드 정보, 비밀번호, 은행 정보 등과 같은 개인 정보를 기반으로 하는데 여기서는 공개키 암호화와 전자 서명이 핵심 기술로, 이 기술은 수치 알고리즘과 정수론 등을 기반으로 만들어진다.

사실 위의 예들은 직접적인 구현을 말하자면 현 문서의 범위를 벗어나는 문제들이다. 그러나 이러한 문제를 해결하는 데 필요한 기본적인 방법들을 살펴볼 수는 있다. 그 예는 다음과 같다.
- 인접 분기점 간의 거리가 모두 표시된 도로 지도가 있다. 한 분기점에서 다른 분기점까지 가는 길 중 최단 경로를 찾으려하는데 이미 거쳐 간 분기점은 다시 지나지 않는다고 가정해도 많은 경로가 가능할 것이다. 여기서 최단 경로를 어떻게 찾을 수 있을까? 해당 문서는 이러한 문제를 해결하는 방법을 학습한다.
- 부품의 집합과 관련된 기계 설계도가 있으며 각 부품은 다른 부품의 요소를 포함할 수도 있다. 그리고 이 부품을 사용하는 다른 부품이 나타나기 전에 이 부품이 먼저 등장하도록 부품을 열거해야한다. 만약 설계도가 n개의 부품으로 구성된다면 가능한 순서는 `n!`가지다. 여기서 n!은 계승 함수이다. 계승 함수는 지수 함수보다 빠르게 커져, 부품을 몇 개만 사용하는 경우가 아니라면 어떤 부품이 사용하는 다른 부품보다 항상 먼저 나오도록 각 순서를 만들어 검증하는 일이 현실적으로 불가능하다. 이를 효율적으로 푸는 방법을 학습할 수 있다.
  - 레고로 생각해보자. 상식적으로 레고 블록으로 특정 구조물을 만들 때, 먼저 아래에 있는 블록들을 쌓아야 그 위에 다른 블록을 올릴 수 있을 것이다. 즉 특정 부품이 다른 부품에 의해 사용된다면, **반드시 그 부품이 먼저 완성되어야하고**(의존 관계를 만족), **부품 설계도 상의 의존 관계를 따라 부품의 순서를 정렬해야한다.**(정렬 순서)
  - n!은 팩토리얼(계승)을 의미하는데 이는 수학에서 주어진 자연수 n에 대해, n부터 1까지의 모든 자연수를 곱한 값을 의미한다. 팩토리얼은 계승이라고도 불린다. 팩토리얼은 주로 조합론이나 순열 계산, 재귀적 문제를 풀 때 자주 사용된다.

실제로 이 문서에서 다룰 내용에 비해 앞서 나열한 예는 극히 일부에 불과하다. 하지만 다른 흥미로운 알고리즘 문제에서 발견되는 다음 두가지 특징을 잘 보여준다.

1. 후보해는 많지만 대부분이 문제의 해가 아니다. 문제의 해 혹은 최적해를 찾는 일은 매우 도전적인 일이다.(쉽게 말해 가능한 답은 많지만, 실제로 정답이 되는 건 몇 개뿐이고, 그중에서도 가장 좋은 답을 찾는 건 어렵다)
2. 실용적인 응용 예가 존재한다. 최단 경로 문제의 예시만 보더라도 그렇다. 트럭이나 기차를 이용하는 운송 회사는 도로망이나 철로망에서 최단 경로를 찾아 노동과 연료 비용을 줄여 경제적 이익을 얻을 수 있다. 내비게이션 앱을 이용해 길을 찾아갈 경우에도 유용하게 사용된다.

모든 문제가 알고리즘을 이용해 후보해의 집합을 쉽게 찾을 수 있는 것은 아니다. 예를 들어 신호의 샘플을 표현하는 수치가 있다고 하자. 이 샘플의 `이산 푸리에 변환`을 계산하려고 한다. 이 문제를 해결하는 데 효율적인 알고리즘인 고속 푸리에 변환(FFT, Fast Fourier Transform) 역시 소개할 것이고, FFT를 계산하기 위한 하드웨어 회로의 설계도 간단히 설명한다.
- 이산 푸리에 변환(discrete fourier transform)이란 샘플 신호에서 주파수 세기가 다양하게 결정 되도록 수치적인 계수를 만들면서 `시간 영역`에서 `주파수 영역`으로 변환하는 것을 의미한다.
  - 시간 영역은 시간에 따른 데이터 변화를 나타내는 방식으로 쉽게 생각하면 음악을 들을 때 시간에 따라 들리는 소리(파형)를 관찰하는 것 정도로 생각 가능하다.
  - 주파수 영역은 데이터가 어떤 주파수 성분들로 구성되어 있는지를 나타내는 방식으로 쉽게 생각하면 음악에서 특정 음(베이스, 드럼, 보컬 등)의 비율을 분석하는 것 정도로 생각 가능하다.
- 이산 푸리에 변환은 신호 처리의 핵심일 뿐만 아니라 데이터 압축과 큰 다항 함수 및 정수의 곱셈에도 응용된다.

### 자료구조
여러 자료구조들 역시 다룰 것이다. 자료구조는 자료를 편리하게 접근하고 변경하기 위해 자료를 저장하거나 조직하는 방법을 말한다. 모든 목적에 가장 맞는 단일 자료구조는 당연히 존재하지 않으므로, 각 자료구조의 장점과 한계를 잘 아는 것이 중요하다.

### 기술
언젠가 우리는 알려진 알고리즘도 찾을 수 없는 문제를 접하게 될 것이다. 여기서 우리는 알고리즘을 스스로 개발하고 그것이 타당한 해를 제시하는지 증명하며, 효율성을 이해할 수 있도록 알고리즘을 설계하고 분석하는 기법을 알 수 있다.

### 난제
아마 이 문서의 내용은 대부분 효율적인 알고리즘에 대해 서술할 것이다. 효율성에 관한 일반적인 척도는 속도, 즉 알고리즘이 결과를 내는 데 걸리는 시간이다. 그러나 최적해 자체가 알려지지 않은 문제도 많다. 후에 다룰 `NP-완비`로 알려진 문제이다.

- NP-완비 문제는 상당히 흥미로운 문제인데 몇 가지 이유가 존재한다.
- 첫째로, 이 문제에서 최적해를 찾는 효율적인 알고리즘이 아직 발견되지 않았지만 그런 알고리즘이 존재할 수 없음을 증명한 사람도 없다는 점이다. 즉 이 문제에 대한 효율적인 알고리즘이 존재하냐 마냐조차도 모른다.
- 둘째로, 이러한 문제 중 단 한 문제에 대한 효율적 알고리즘이 존재한다면 다른 모든 NP-완비 문제에 대한 효율적 알고리즘도 존재한다는 사실이다. 이러한 특징들이 사람들을 미치게 만든다.
- 세번째로, NP-완비 문제 중 일부가 효율적 알고리즘이 알려진 다른 문제와 일치하지는 않지만, 유사점이 존재한다는 점이다. 즉 문제 정의를 조금만 바꿔도 알려진 효율적 알고리즘의 성능에 엄청난 변화가 생길 수 있음을 의미한다.
- 그렇다고 이러한 문제가 현실에서 발견하기 힘든 것도 아니다. 오히려 매우 흔한 문제가 NP-완비 문제인 경우가 허다하다.
  - 현실적인 예로, 중앙 물류 창고를 보유한 트럭 회사를 생각해보자.
  - 이 회사는 매일 트럭에 창고의 짐을 실어 여러 지역을 돌면서 배송한다. 그리고 날이 저물 무렵에는 다음 날 다시 짐을 실을 수 있도록 창고로 되돌아와야 한다.
  - 여기서 회사는 비용 절감을 위해 운행 전체 거리를 줄이려면 모든 지역을 어떤 순서로 운행하는 것이 가장 좋은지 알고 싶어한다.(이 문제가 잘 알려진 "순회 판매원 문제" 이다.)

저러한 문제에 대해 알려진 최적의 알고리즘은 없으나, 어느 정도 좋은 성능을 보여주는 알고리즘은 분명 존재한다. 나중에 다룰 "근사 알고리즘"이 바로 그러하다.

### 병렬성

오랫동안 프로세서의 클록 속도가 일정한 비율로 증가하는 것을 기대할 수 있었찌만 물리적 한계로 인해 클록 속도를 계속 증가시키기 어려워졌다. 이유는 심플하다. 클록 속도가 증가하면 전력 밀도도 초선형적으로 증가해 클록 속도가 충분히 높아지면 컴퓨터 칩이 녹아버릴 위험이 생기기 떄문이다.

그래서 칩은 시간당 계산 성능을 늘리기 위해 단 하나가 아닌 여러 계산을 처리할 수 있도록 여러 "코어(Core)"를 가지도록 설계된다. 멀티코어 컴퓨터는 한 개의 칩 위에 컴퓨터 여러 대가 나란히 놓인 것으로 생각할 수 있다. 즉 일종의 **병렬 컴퓨터**이다.

이러한 멀티코어 컴퓨터로부터 최고의 성능을 얻기 위해선 알고리즘을 설계할 때 **병렬성**을 염두에 두어야 한다. 우리는 멀티코어의 이점을 갖는 멀티스레트 알고리즘을 위한 모델을 살펴볼 것이다.

우리는 대개 알고리즘이 실행되기 시작할 때 모든 입력 데이터를 사용할 수 있다고 가정한다. 알고리즘 설계 작업의 대부분은 동일한 가정을 전제로 한다.

그러나 실제 현실 세계에서의 입력 데이터는 **실제로 시간이 지남에 따라 도착하며, 알고리즘은 향후 어떤 데이터가 도착할지 모르는 상태에서 진행 방법을 결정해야 한다.**

처음부터 모든 입력이 존재하는 것이 아니라 시간이 지남에 따라 입력을 받는 알고리즘인 `온라인 알고리즘` 역시 살펴보겠다.

## 기술로서의 알고리즘

만약 컴퓨터가 무한히 빠르고 메모리 비용이 들지 않는다고 가정을 했을 때, 이런 경우에도 알고리즘을 배울 필요가 존재할까? 개발한 알고리즘이 타당한 답을 출력하면서 종료된다는 것을 확신하고 싶은 이유만으로 이 질문에 대한 대답은 'yes'가 될 것이다.

컴퓨터가 무한히 빠르다면 타당한 알고리즘들 역시 무한히 빠를 것이다. 우리는 이러한 컴퓨터를 가졌더라도 가장 쉽게 구현할 수 있는 것을 가장 자주 사용할 것이다.

현실의 컴퓨터는 빠를 수는 있지만 무한할 수는 없으며 메모리 비용이 든다. 계산 시간은 한정된 자원이고, 이는 메모리 공간 역시 동일한 경우이다. 단순히 생각해봐도 자원을 효율적으로 사용해야 되며, 시간과 공간 측면에서 효율적인 알고리즘이 필요하다.

### 효율성

동일한 문제를 해결하기 위한 알고리즘이 효율성 면에선 극적으로 다를 수 있다. 이 차이는 하드웨어나 소프트웨어의 스펙 차이보다 훨씬 심각할 수 있다.

본격적인 내용을 다루지는 않겠지만, 간단한 예시를 들어보자. 두 가지 정렬 알고리즘을 살펴볼 것인데, 하나는 삽입 정렬 알고리즘으로 n개의 값을 정렬하는 데 대략 c1 * n^2 시간이 걸리며 c1은 n에 독립적인 상수항이다.
두번째는 병합 정렬 알고리즘으로, 대략 c2 * n lg n 시간이 걸리는데 여기서 lg n은 log2 n이고 c2는 n에 독립적인 또 다른 상수다. 여기서 삽입 정렬은 보통 c1 < c2가 되는, 즉 병합 정렬보다 작은 상수를 가진다.
여기서 상수는 입력 크기 n에 비해 수행 시간에 영향을 훨씬 작게 준다는 사실을 간단한 계산으로 알 수 있다.

```
예를 들어 삽입 정렬은 2*n^2. 병렬 정렬은 64*n lg n이라고 하자
삽입 정렬은 입력값 만큼의 수행 시간이 걸리지만 병합 정렬은 이보다 훨씬 작은 lg n 만큼의 시간만 소요된다.
이는 n이 1000이라고 가정할 때 병합 정렬은 고작 10 정도밖에 안되는 것이다.
상수항의 차이가 아무리 작더라도 병합 정렬이 더 빨라지는 교차점이 항상 존재하게 되는 것이다.
```

좀 더 구체적인 예를 들어 빠른 컴퓨터 A에 삽입 정렬을 실행하고 느린 컴퓨터 B에 병합 정렬을 실행해보자. 두 컴퓨터는 1000만 개의 숫자를 정렬해야한다.
컴퓨터 A는 초당 100억개의 명령어를 실행하고(아마 현시점에 존재하는 어떠한 단일 순차 컴퓨터보다 빠를것이다.) 컴퓨터 B는 초당 1000만개의 명령어를 실행한다고 가정하자.(이는 지금 어지간한 저가 컴퓨터보다도 훨씬 느릴 것이다.)

심지어 여기에 더해 A컴퓨터는 세계 최고의 프로그래머가 기계어로 작성하여 코드가 n개의 숫자를 정렬하는 데 2n^2개의 명령어가 필요하다고 가정해보자. 반면에 병합 정렬은 말 그대로 평범한 프로그래머가 컴파일러를 사용하는 고급 언어를 사용하여 구현하고 그 결과 코드에 50 n lg n 개의 명령어가 필요하다고 가정해보자. 이 둘의 실제 실행 시간은 어떻게 될까?

A컴퓨터는 1000만개의 숫자를 정렬하는데 약 2만초 정도 걸린다. 이는 5시간이 넘는 시간이다. 반면 B컴퓨터는? 약 1163초로 20분도 채 걸리지 않는다.

여기서 입력값이 더욱 커져서 1억개의 숫자라고 가정하면 두 알고리즘의 성능 차이는 더욱 극명하게 드러난다. 같은 조건에서 A컴퓨터는 23일 이상 걸리는 시간이 걸리지만, B컴퓨터는 4시간도 걸리지 않는다.

실제 현실 세계에서 30분마다 1억 건 이상의 웹 검색이 이루어지고, 1분마다 1억 건 이상의 이메일이 전송되는걸 생각하면 좋은 알고리즘을 택하는건 필수 불가결한 사항이다.

### 알고리즘과 다른 기술들

앞서 본 예는 하드웨어처럼 알고리즘도 하나의 기술임을 보여준다. 즉 전체 시스템의 성능은 빠른 하드웨어 뿐만 아니라, 얼마나 효율적인 알고리즘을 선택하느냐에 따라서도 결정된다. 다른 컴퓨터 기술들과 함께 알고리즘 분야에서도 큰 발전들이 따라왔다.

동시대의 다음과 같은 발전된 다른 기술들처럼 컴퓨터 분야에서 알고리즘이 중요할까?
- 발전된 컴퓨터 구조와 제조 기술
- 사용하기 쉽고 직관적인 그래픽 인터페이스
- 객체 지향 시스템
- 통합적인 웹 기술
- 빠른 유무선 네트워킹
- 머신러닝
- 모바일기기

너무나도 당연히 답은 **그렇다**이다. 응용 프로그램 수준에서 알고리즘이 필요 없는 것 같은 프로그램도 실제로는 알고리즘에 상당히 의존한다.
프로그램에서 빠른 하드웨어가 중요하다면, 그 하드웨어 설계에는 알고리즘이 중요하다. 그래픽 인터페이스가 중요하다면 그 설계 단계에서 알고리즘이 중요한 역할을 한다. 네트워킹이 중요한 프로그램이라면 네트워크에서 경로를 찾는 문제는 전적으로 알고리즘에 달려있다. 결국 알고리즘은 **현대 컴퓨터 분야에서 거의 모든 기술의 중심에 있다고 볼 수 있다.**

흔히 AI의 기반이 되는 기술로 알려져있는 머신러닝은 언뜻 보기에 알고리즘 설계 과정을 자동화하는 머신러닝은 알고리즘에 대한 학습을 불필요하게 만드는 것처럼 보일 수 있다. 하지만 사실은 정반대이다. 머신러닝이야말로 그 자체가 알고리즘의 집합이다. 현재 머신러닝의 성공은 주로 인간으로서 올바른 알고리즘이 무엇인지 잘 모르는 문제에 대한 것으로 보이는데, 이는 빈대로 말하자면 인간이 잘 이해하는 알고리즘의 문제의 경우 머신러닝 접근 방식보다 더 성공적이다.

결론적으로 알고리즘에 대한 지식과 기술을 얼마나 알차게 학습했느냐가 숙련된 프로그래머와 초보자를 구분하는 기준이 될 수 있다.
