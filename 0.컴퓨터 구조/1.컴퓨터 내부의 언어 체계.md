# 개요

우리가 사용하는 실제 문자 언어를 생각해보자. 문자 언어는 기호를 나열한 것이다. 언어마다 기호 자체가 달라질 수도 있고, 읽는 순서 역시 달라질 수 있으며, 기호의 순서에 따라 의미가 달라지기도 한다.
모든 언어의 뜻은 이러한 체계를 바탕으로 만들어진 기호의 집합으로 **인코딩**된다. 하지만 이것만으로는 충분하지 않다. 더욱 중요한 것은 바로 **문맥**인데 모두가 같은 문맥을 공유하여 **같은 기호에 같은 뜻을 부여할 수 있어야 한다.**
**현실 세계에서도 그렇듯, 언제나 문맥을 명확히 식별할 수 있는 것은 아니다. 이는 컴퓨터 언어에도 마찬가지인 문제이다.**
여기서 말하는 '컴퓨터 언어'는 단순히 프로그래밍 언어만을 의미하지 않는다. 컴퓨터 언어란 **컴퓨터 내부의 전반적인 체계를 이해하기 위한 최소 단위의 표현 방식**이라 생각하면 된다. 이는 **이진법을 바탕으로 한** 데이터 표현, 논리 연산, 명령어 집합 등을 포함하는 개념이다.

## 비트

문자 언어의 틀을 이루는 세 가지 구성요소에 대해 적자면 다음과 같다.

  - 기호가 들어갈 상자
  - 상자에 들어갈 기호
  - 상자의 순서

이러한 구성요소는 컴퓨터 언어에서도 마찬가지라고 볼 수 있다. 먼저 상자에 대해 생각해보면, 자연어(현실 세계에서 사용되는 언어)에선 **문자**라고 부르는 것을 컴퓨터에선 **비트**라고 부른다. 

**비트**는 2진법을 사용한다는 뜻의 바이너리(binary)와 숫자를 뜻하는 디지트(digit)가 합쳐진 말이다.(여담으로 디지트라는 말은 10진수를 표현 10가지 기호를 뜻하는 말이다.) 비트는 2진법을 사용하는데, 오직 두 가지 기호를 여러가지 방식으로 조합해 이어붙여서 복잡한 정보를 표현한다. 여기서 중요한건 **기호는 추상적인 개념**이라는 사실을 기억해야한다. 이는 숫자가 될 수 있고 참 거짓이 될 수도 있다.

## 논리 연산

비트의 사용법 중 하나는 예/아니오 질문에 대한 답을 참/거짓으로 표현하는 것이다. 하지만 **하나의 비트로 표현할 수 없는 상황**이 많이 발생한다. 이러한 경우 **여러 비트를 조합해 문제를 해결**해야 하는데, 이때 사용하는 것이 바로 **논리 연산**이다. 논리 연산은 여러 비트를 조합하여 새로운 값을 만들어내는 방식으로, 대표적인 연산으로는 **AND, OR, NOT** 등이 있다.

### 불리언 대수

불리언 대수는 1800년대 조지 불이 만들어 낸 연산규칙의 집합으로서, 비트에 대해 사용할 수 있는 대표적인 연산 중 하나이다. 결합 법칙, 교환 법칙, 분배 법칙을 그대로 적용 가능하다.
기본적으로 불리언 연산자는 **AND, NOT, OR** 세 가지고, 합성 연산으로서 **XOR** 이 존재한다.

- **AND**
  - 둘 이상의 비트에 작용하는 연산으로서, 2비트 연산인 경우, 두 가지 비트가 모두 참일 경우에 결과가 참이 된다. 즉 **각 비트가 모두 참일 때** 연산의 결과가 참이 된다.
- **NOT**
    - 논리적 반대를 의미하며 하나의 비트에도 작용 가능하다. 예를 들어 어떠한 비트 하나가 참인 경우에 NOT 연산을 하면 거짓이 된다.
- **OR**
    - 이 연산도 둘 이상의 비트에 작용하는 연산으로, **각 비트 중 하나라도 참이라면** 연산의 결과도 참이 된다.
- **XOR**
    - 배타적(Exclusive) OR 이라는 뜻으로 첫번째 비트와 두번째 비트가 **서로 다를 때만 참이 된다.**
 
#### 드모르간의 법칙 

드모르간의 법칙은 두 개의 논리 연산식을 변환하는 데 사용되는 규칙으로, **NOT, AND, OR 연산 간의 관계를 재정립할 수 있다.** 이 법칙을 이용하면 특정 논리식을 더욱 간단하게 표현하거나, 특정 상황에서 논리 연산을 쉽게 이해할 수 있다. 

드모르간의 법칙은 다음과 같은 두 가지 주요 형태로 표현된다:

**1. NOT (A AND B) = (NOT A) OR (NOT B)** 

**2. NOT (A OR B) = (NOT A) AND (NOT B)**

즉, AND 연산과 OR 연산을 반대로 바꾸면서 각 항에 NOT을 붙이는 방식이다. 이 말은 NOT을 충분히 사용하면 AND를 OR로, 혹은 역으로도 대신할 수 있다는 것이다.
컴퓨터에서 입력을 항상 원하는 형태로 얻을 수는 없기 때문에 이러한 성질은 매우 유용하다.
저 법칙을 응용하여 다음과 같은 예시를 적을 수도 있다. 왼쪽에는 **긍정적인 논리**(정논리), 오른쪽에는 **부정적인 논리**(부논리)를 적었다.

```
            A OR B                                       (NOT A AND NOT B)                                   NOT(NOT A AND NOT B)
----------------------------------          ---------------------------------------------                  ------------------------
춥다 | 비가 온다 | 코트를 입는다                  NOT 춥다  | NOT 비가 온다 | NOT 코트를 입는다                      코트를 입는다
F        F          F                           F            F                F                                       F
F        T          T                  =>       F            T                F                   NOT                 T
T        F          T                           T            F                F                   =>                  T
T        T          T                           T            T                T                                       T
```

즉 A OR B 는 NOT(NOT A AND NOT B)와 같다는 사실이 도출된다. 이러한 드모르간의 법칙 사용은 **연산을 최소로 사용하여 비용을 최소화할 수 있다.**
<br>

## 정수를 비트로 표현

십진수를 생각해보자. 십진수는 밑이 10인 수 체계다. 이는 곧 자릿수가 10의 거듭제곱 꼴로 나타내진다. 5018이라는 숫자가 있을 때 이를 다르게 표현해보면
```
5*10^3 + 0*10^2 + 1*10^1 + 8*10^0 = 5018
```
이렇게도 표현이 가능하다. 

비트를 사용할 때도 이와 비슷하게 표현이 가능하다. 밑이 2라는 점 때문에 **기호를 담을 상자, 자릿수**가 더 많이 필요하다는 차이점이 있을 뿐이다.
예를 들어 숫자 9를 생각해볼 때, 십진수에선 한 자릿수로만 해결이 가능하다. 이진수는 **0과 1**만 사용이 가능하고 밑을 2로 가지기 때문에 1보다 큰 수를 표현할 때 부터 자릿수가 늘어난다. 두번째 상자, 즉 두번째 자릿수에는 어떤 이름이 붙을까?
바로 **2의 자리**이다. 이런식으로 자릿수에 따라서 2를 거듭제곱하여 값의 자리를 표현한다. 즉 숫자 '9'를 이진수로 표현하면 다음과 같은 결과가 나온다.

```
1*2^3 + 0*2^2 + 0*2^1 + 1*2^0 = 9 이를 이진수로 표현하면 -> 1001라는 4비트 수가 된다.
```

비트는 기호를 담을 상자라고 말을 했고, 여기서는 이진수의 자릿수로 표현이 된다고 하였다. 이는 다시 말해서 **임의의 비트로 값의 개수와 값의 범위를 산출 가능하다는 것이다.** 
다음 예시는 여러 가지 비트 개수를 사용해 표현할 수 있는 수의 범위를 보여준다.

```
비트 개수 | 값의 개수 | 값의 범위
    4          16        0-15
    8          256       0-255
    12         4096      0-4095
    16         65536     0-65535
    등등... 
```

2진수에서 가장 오른쪽의 비트를 **가장 작은 유효 비트**(**least significant bit**) 라고 부르고, 가장 왼쪽의 비트를 **가장 큰 유효 비트**(**most significant bit**)라고 부른다.

  - **가장 작은 유효 비트**(LSB)
    - LSB는 이진수 표현에서 가장 오른쪽에 위치한 비트를 의미한다. LSB는 숫자 값에 가장 작은 영향을 미치는 비트로, 이 비트를 바꾸면 전체 값의 변화폭이 가장 작다.
    - 2진수의 특성상 LSB가 1이면 홀수, LSB가 0이면 짝수가 된다. 이 방식으로 홀/짝수 확인을 빠르게 할 수 있다.
   
  - **가장 큰 유효 비트**(MSB)
      - MSB는 숫자 값에 가장 큰 영향을 미치며, 이 비트를 바꾸면 값의 변화폭이 가장 크다.
      - 후술하겠지만, 부호 있는 정수에서 MSB는 부호를 결정하는 역할도 한다.
   
  - **공통 사항**
    - 데이터 전송 시 MSB First와 LSB First 방식으로 구분할 수 있다.
    - 예를 들어, 네트워크 전송 시 프로토콜에 따라 먼저 전송할 비트를 결정하는 데 MSB나 LSB가 중요한 역할을 한다.
    - **빅 엔디언**(Big-Endian) 방식은 MSB를 먼저 전송하고, **리틀 엔디언**(Little-Endian) 방식은 LSB를 먼저 전송한다.
    - 이러한 방식은 **CPU 아키텍처**에 따라 달라지며, 데이터 전송의 호환성 문제를 다룰 때 **엔디언**을 고려해야 한다.
