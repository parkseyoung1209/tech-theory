# Merge Sort

Merge Sort는 배열을 반으로 나누고, 각 반쪽을 재귀적으로 정렬한 후 두 반쪽을 병합하여 정렬하는 분할 정복 알고리즘이다.
좀 더 쉽게 말하자면 해당 배열의 요소들을 최대한 독립적으로 분리시킬 만큼 나눈 후 작은 배열들끼리 비교 후 다시 병합을 반복하여 정렬하는 것이다.
컴퓨팅의 선구자 **존 폰 노이만(John von Neumann)**이 이 알고리즘을 발명했다고한다.


## 핵심 개념

1. 분할 (Divide)
- 배열을 반으로 나눈다
- 나뉜 배열을 다시 반으로 나눈다.
- 이 과정을 요소가 하나가 될 때까지 반복한다.
2. 병합 (Merge)
- 나뉜 배열을 정렬하면서 병합한다.
 - 두 개의 정렬된 배열을 비교하여, 작은 값을 결과 배열(aux)에 복사한다.
 - 두 배열 중 하나가 먼저 소진되면, 남아 있는 값을 그대로 복사한다.
3. 정복 (Conquer)
- 병합 과정을 반복하며 전체 배열을 정렬한다.


## 단점

단점이라면 결국 추가적인 배열의 존재가 필요하다는 것이다. 이는 메모리 사용량을 증가시킨다는 단점으로 이어진다.

## 병합 과정의 원리

결국 이 알고리즘의 핵심은 병합이다. 병합 과정은 두 개의 정렬된 배열을 비교하며 하나의 정렬된 배열로 만드는 것이다.

1. 두 배열의 첫 번째 요소를 비교한다.
2. 더 작은 요소를 결과 배열(aux)에 복사하고, 해당 배열의 포인터를 이동.
3. 두 배열 중 하나가 소진되면, 나머지 요소를 결과 배열에 복사한다.
4. 병합된 결과를 원래 배열에 다시 복사한다.

## 예제 코드


```java
public clas Merge {
  private static String[] aux;
  public static void merge(String[] a, int low, int mid, int high) {
    int i = low, j = mid, N = high - low;
    for(int k = 0; k < N; k++) {
      if (i == mid) aux[k] = a[j++];
      else if (j == high) aux[k] = a[i++];
      else if (a[j].compareTo(a[i]) < 0) aux[k] = a[j++];
      else aux[k] = a[i++];
      }
      for(int k = 0; k <N; k++) {
        a[low + k] = aux[k];
      }
  }
  public static void sort(String[] a) {
    aux = new String[a.length];
    sort(a, 0, a.length);
  }
  public static void sort(String[] a, int low, int high) {
    int N = high - low;
    if(N <=1) return;
    int mid = low + N/2;
    sort(a, low, mid);
    sort(a, mid, high);
    merge(a, low, mid, high);
  }
}
```

해당 코드는 병합 정렬을 재귀적인 방법으로 구현한 것이다. 
사실 이 알고리즘도 그렇고 웬만한 알고리즘은 **추상적인 개념보다는 실제 구현된 코드를 보고 이해하는게 중요** 하면서도 매우 어렵기 때문에 최대한 코드의 동작 구조를 써보려고 한다.

우선 코드를 단순히 메서드 순서대로 쓰기 보단 하단의 sort 메서드 두 개를 먼저 우선적으로 따라갈 필요가 있다.

### sort 메서드(보조 배열 생성 실제 동작 sort 메서드 호출)

``` java
private static String[] aux;
/*
/
/ merge 메서드
*/
public static void sort(String[] a) {
    aux = new String[a.length]; // 보조 배열을 원본 배열과 같은 크기로 초기화
    sort(a, 0, a.length); // 정렬 시작
}
```

이 메서드는 aux라는 배열을 실제 원본 배열과 같은 크기로 구성시킨 다음 후술할 실제로 동작할 sort 메서드를 호출한다.

여기서 끝에 들어가는 a.length는 후술할 sort 메서드에는 배열의 길이가 필요하기 때문에 그대로 넣은 것이다.

### sort 메서드 (재귀 호출)

``` java
public static void sort(String[] a, int low, int high) {
    int N = high - low; // 배열의 길이 계산
    if(N <= 1) return; // 배열이 1개 이하인 경우 재귀 종료
    int mid = low + N / 2; // 배열을 반으로 나눔
    sort(a, low, mid); // 왼쪽 반을 정렬
    sort(a, mid, high); // 오른쪽 반을 정렬
    merge(a, low, mid, high); // 두 반을 병합
}
```

먼저 현재 처리 중인 배열의 길이를 계산한다. 만약에 배열의 크기가 1 이하라면 이미 정렬된 상태이기 때문에 아무것도 하지 않고 종료한다.

그리고 배열을 중간 위치로 나눠서 좌우 두 개의 하위 배열로 나눈다.
여기서 놓치지 말아야할 부분은 메서드상으로 (a, 0, 4)가 입력된 메서드의 끝자락 merge 메서드는 상단의

```
sort(a, low, mid); // 왼쪽 반을 정렬
sort(a, mid, high); // 오른쪽 반을 정렬
```

메서드에서 실행되는 merge 메서드가 우선 실행된 후 끝에서 병합된다는 사실이다. 

정확히는 분할 자체는 각 요소를 하나만 가지는 배열에 도달할 때까지 멈추지 않는다.

이후 `if(N <= 1) return;` 조건문을 만나 분할 작업이 끝나면 (a, 0, 2)에 대한 merge(a, 0, 1, 2)가 호출된다.

자 마지막으로 merge 메서드로 가보자.

### merge 메서드

``` java
public static void merge(String[] a, int low, int mid, int high) {
    int i = low, j = mid, N = high - low;
    for(int k = 0; k < N; k++) {
        if (i == mid) aux[k] = a[j++]; // 왼쪽 배열이 다 소진된 경우
        else if (j == high) aux[k] = a[i++]; // 오른쪽 배열이 다 소진된 경우
        else if (a[j].compareTo(a[i]) < 0) aux[k] = a[j++]; // 오른쪽 배열의 값이 더 작은 경우
        else aux[k] = a[i++]; // 왼쪽 배열의 값이 더 작은 경우
    }
    for(int k = 0; k < N; k++) {
        a[low + k] = aux[k]; // 병합된 값을 원래 배열에 복사
    }
}
```

자 예를 들어서 실제 문자열 배열이 ["D","B","A","C"]라고 치자.

상단의 sort 메서드를 걸치면 배열은 [D,B] [A,C]로 나누어질 것이다.

여기서 merge 메서드는 실제 길이가 4인 배열의 정보를 바탕으로 만들어진 low, mid, high 값을 가진다.
즉 왼쪽 배열은 (a,0,1,2)가 들어가게 되고, 오른쪽 배열은 (a,2,3,4)가 들어가게 된다.

하나의 배열의 작동 원리만 봐도 다른쪽의 원리가 보인다.

결론적으로 D, B라는 요소는 a라는 배열의 a[0], a[1]인데 이걸 해당 로직의 조건문을 이용해 aux의 0번 인덱스와 1번 인덱스에 넣는다.

이 작업이 마무리 되면 하단의 반복문을 통해 병합된 값을 원래 배열에 복사한다.

그리고 이렇게 재구성된 [B,D] [A,C] 배열을 처음에 실행된 sort(a, 0, 4)의 끝자락에 있는 merge 메서드로 또 재구성해 [A,B,C,D]로 정렬하는 것이다.

이렇게 병합 정렬은 "나누기 -> 정렬 -> 병합" 과정을 재귀적으로 반복하면서 배열을 정렬해 나가는 알고리즘이다.

## 효율성

### Merge Sort의 시간 복잡도

**분석**
- 분할 단계: 배열을 계속 반으로 나누므로 분할 단계는 O(log N)입니다.
- 병합 단계: 두 배열을 비교하며 병합하므로 각 단계에서 O(N) 시간이 필요합니다.
**총 시간 복잡도**
- 두 단계를 곱한 결과 O(N log N)이 나온다.
- 이는 이전 문서에서 언급만 한 버블 정렬이나, 실제 구현까지 한 삽입 정렬보다 훨씬 효율적이다.

다만 추가적으로 실제 배열 길이를 가진 보조 베열을 사용하기에 추가적인 소모가 있다.

또한 속도면에선 더 빠른 정렬 알고리즘이 존재하지만 동일한 값의 요소 간 순서가 유지된다는 점과, 입력 배열의 초기 상태(거의 정렬/무작위)와 관계없이 일정한 시간 복잡도를 가진다.


## 결론

해당 강의에서는 실제로 테스트까지 진행하였으며 100만 개의 데이터 처리에 단 1초, 20초에는 약 1600만 개의 데이터를 작업할 수 있었다. 이는 몇 분 안에 10억 개의 작업을 처리 가능하다는 말이다.

물론 더 나은 속도를 가진 정렬 알고리즘을 찾기위한 노력은 끝없이 연구 되었고 병합 정렬보다 더 빠른 방법들도 실제로 발견되었다.

그럼에도 삽입 정렬과 비교해보면 이 방법이 우리의 문제를 확실히 해결해준다. **단순 구현이 아닌 확장성을 가진 알고리즘은 실제로 개발할 프로그램에도 효율적으로 작동한다.**
