# 가장 긴 반복된 문자열 (Longest Repeated Substring, LRS)
**Longest Repeated Substring** (**LRS**) 문제는 주어진 문자열에서 최소 두 번 이상 나타나는 가장 긴 부분 문자열을 찾는 문제이다. 
이 문제는 유전체학, 음악 분석, 암호학 등 여러 응용 분야에서 중요한 패턴이나 반복되는 구조를 분석하기 위해 사용된다.

예를 들어, 문자열 `banana`에서 가장 긴 반복 부분 문자열은 `ana`이다. 이 부분 문자열은 두 번 나타나며, 가장 길기 때문에 답이 된다.


## 문제 해결 방법

이 문제를 해결하는 데는 여러 가지 접근법이 있다. 여기서는 대표적인 두 가지 방법을 설명한다.
**브루트 포스**(무차별 대입) 방법과 **접미사 배열**(Suffix Array)을 이용한 방법이다.

1. 브루트 포스

**브루트 포스** (brute force)는 모든 가능한 경우의 수를 하나씩 검사하는 방식이다. 이 방법은 단순하지만 효율적이지 않다. 
문자열의 모든 위치에서 가능한 모든 부분 문자열을 비교하고, 그 중에서 가장 긴 공통 부분 문자열을 찾는 방식으로 동작한다.

```java
public class LRS {
  private static String lcp(String s, String t) {
// Longest Repeated Substring 해당 메서드는 두 문자열의 가장 긴 공통 접두사(Longest Common Prefix)를 찾는 메서드이다.
브루트 포스 방법도 후술할 접미사 배열 방법도 이 메서드를 우선으로 필요한다.
    int N = Math.min(s.length(), t.length());
    for (int i = 0; i <N; i++) {
      if(s.charAt(i) != t.charAt(i)) return s.substring(0,i);
      return s.substring(0, N);
    }
  }
  public static String lrs(String s) {
    int N = s.length();
    String lrs = "";
    for (int i = 0; i < N; i++) {
      for (int j = i+1; j < N; j++) {
        String x = lcp(s.substring(i, N), s.substring(j, N));
        if (x.length() > lrs.length()) lrs = x;
      }
    }
  return lrs;
  }
  public static void main(String[] args) {
    String s = StdIn.readAll();
    StdOut.println(lrs(s));
  }
}
```

2. Suffix 배열

**접미사 배열**(Suffix Array)을 사용하는 방법은 정렬을 활용하여 문제를 효율적으로 해결하는 방식이다. 
이 방법은 무려 수십 년 전에 발견되었지만 매우 효율적인 방법으로 알려져 있으며, 시간 복잡도는 O(N log N)이다.

``` java
public static String lrs(String s) {
  int N = s.length();
  String[] suffixes = new String[N];
  for (int i = 0; i < N; i++) {
    suffixes[i] = s.substring(i,N);
  }
  Merge.sort(suffixes); // 3번 문서에서 나온 Merge 클래스를 사용한것이다.

  Stringlrs = "";

  for (int i = 0; i < N-1; i++) {
    String x = lcp(suffixes[i], suffixes[i+1]); // 상단 브루트 포스에서도 사용한 lcp 메서드를 사용한다
    if (x.length() > lrs.length()) lrs = x;
  }
  return lrs;
}
```

## 해당 강의 후반부에 나오는 논의

이 강의에서 소개된 방식은 **접미사 배열**을 사용하여 가장 긴 반복된 문자열 문제를 해결하는 효율적인 방법이다. 
실제로 이 접근법은 다양한 응용 분야에서 매우 중요한 역할을 해왔다고 한다. 과학자들이 입력 크기에 따라 연구를 확장할 수 있는 방식을 개발할 수 있게 된 것이 90년대와 2000년대 초반의 일이다. 
특히 생물정보학 기술의 발전과 함께 데이터의 양이 크게 증가했으며, 이러한 알고리즘은 새로운 연구 개발의 기반이 되었다.

그러나 몇 년 전 해당 강의의 교수는, 이 강의를 준비하기 위해 코드를 테스트하던 중 예상치 못한 문제가 발생했다고 한다. 
프로그램이 실행 도중 충돌하면서 메모리가 바닥났다는 것이다. 이유를 찾기 위해 분석한 결과, Java의 시스템 변경으로 인해 이전에는 잘 작동하던 프로그램이 정상적으로 동작하지 않게 된 것이었다. 
구체적으로는 DNA와 유전자 코드를 연구하는 과학자들과 연구자들이 사용하던 프로그램에서 문제가 발생한 것이었다.

문제의 핵심은 Java의 하위 문자열(substring) 구현 방식의 변경에 있었다고 한다. 
2012년 이전까지, Java는 원본 문자열을 참조하여 하위 문자열을 생성하였다. 
예를 들어, 어떤 긴 문자열이 있을 때, 그 문자열의 특정 구간만 하위 문자열로 사용하고자 할 경우, 원본 문자열을 그대로 참조하여 필요한 부분만을 포인터로 가리키는 식으로 처리하였다. 
이는 메모리 사용 면에서 매우 효율적이었다. 즉, 문자를 실제로 복사하지 않고, 기존 문자열의 특정 위치를 참조하는 방식으로 동작하였다.

하지만 2012년 이후, Java에서는 **하위 문자열을 새로운 문자열로 복사하는 방식**으로 구현이 변경되었다. 이 변경의 이유는 거대한 문자열에서 아주 작은 하위 문자열만을 사용해야 할 때, 원본 문자열 전체를 메모리에 유지해야 하는 문제를 해결하기 위함이었다. 
웹 페이지의 내용처럼 매우 큰 문자열에서 특정 부분만 필요할 경우, 이 방식을 통해 메모리를 더 효율적으로 관리할 수 있게 된 것이다. 따라서 원본 문자열이 더 이상 필요하지 않을 때, 메모리를 해제할 수 있게 된 것이다.

그러나 이 변경으로 인해 하위 문자열을 생성하는 데 선형 시간과 공간이 필요하게 되었고, 이로 인해 일부 프로그램이 성능 문제를 겪게 되었다. 
특히 유전체학과 같이 매우 긴 문자열을 다루는 경우, 이전에는 효율적으로 작동하던 알고리즘이 이제는 메모리와 시간 면에서 큰 부담이 되었다.

해당 문서의 예제 코드는 2012년 이전에는 아무리 긴 문자열이 존재하더라도 해당 문자열의 필요한 부분을 참조하는 것에 불과했기 때문에 추가적인 메모리 할당이 필요가 없어 잘 돌아갔다.
허나 현재의 자바는 참조가 아닌 실제로 또 다른 문자열을 생성, 즉 **새로운 메모리 공간을 할당** 하기 떄문에 한계점이 존재한다는 것이다.

허나 이러한 문제의 해결법은 오히려 명확해진것이다. 
결국엔 기존의 참조 기반 하위 문자열 생성 방식을 커스텀 클래스로 구현하고, 이 클래스를 compareTo 메서드를 통해 정렬 가능하게 하여, LRS 문제를 해결할 때 사용하면 된다.

여기서 중요한건, **알고리즘 자체는 변하지 않았지만, 환경의 변화로 인해 그 구현 방식이 변화된 것이다.**
어쩌면 우리에게 필요한 사고 방식은 **시스템보다는 알고리즘을 신뢰해야 한다는 점**일 수도 있다.

실제로 이 문서의 알고리즘은 자바라는 언어가 생기기도 전에 만들어진 알고리즘이다.
현 예제에서도 lcp+접미사 배열을 사용시에 실행 시간이 O(N^2)에 달한다. 이러한 문제를 해결하기 위해 사람들은 더 정교한 알고리즘을 개발하였으며, 기존보다 훨씬 더 빠른 선형 시간에 실행되는 알고리즘들이 등장하였다.

## 말하고자하는 점

이 강의에서 강조하고자 하는 점은 무엇일까? 결론부터 말하자면 **알고리즘의 성능을 과학적으로 분석하는 것이 매우 중요하다는 것이다.**
효율적인 알고리즘을 사용하면 정렬된 배열을 검색하는 것, 배열을 정렬하는 것, 그리고 이를 바탕으로 더 많은 문제를 해결하는 것이 가능하다. 
기본적으로 수학적 모델을 만들고, 이를 경험적 테스트를 통해 검증하여 알고리즘의 성능을 이해하는 것이다.
우리는 단순히 문제를 해결하기만 하는 것이 아니라, 성능과 효율성을 이해하고 그 문제에 맞는 최적의 방법을 찾는 데 집중해야 한다.
