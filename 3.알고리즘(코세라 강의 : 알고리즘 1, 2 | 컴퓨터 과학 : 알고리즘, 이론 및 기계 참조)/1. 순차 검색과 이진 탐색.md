# 순차 검색
**순차 검색(Linear Search**)은 배열이나 리스트의 처음부터 끝까지 하나씩 확인하면서 원하는 값을 찾는 가장 단순한 탐색 알고리즘이다. 
이 방식은 탐색 대상이 정렬되어 있지 않아도 사용할 수 있다는 점에서 매우 유연하지만, 데이터가 많을 경우 탐색 시간이 오래 걸린다는 단점이 있다.

## 순차 검색의 기본 아이디어
- 배열의 처음부터 마지막까지 차례로 각 요소를 확인.
- 찾고자 하는 값이 존재하면 그 위치를 반환하고, 없으면 -1을 반환.
- 평균적으로는 탐색하려는 값이 배열의 중간에 있을 경우 절반 정도를 확인하게 되며, 최악의 경우 배열의 모든 요소를 검사하게 된다.

## 예제 코드
``` java
public class Generator {
  public static String randomString(int L, String alpha) {
    char[] a = new char[L];
    for(int i = 0; i < L; i++) {
      int t = StdRandom.uniform(alpha.length());
      a[i] = alpha.charAt(t);
    }
  return new String(a);
  }
  public static void main(String[] args) {
    int N = Integer.parseInt(args[0]);
    int L = Integer.parseInt(args[1]);
    String alpha = args[2];
    for(int i = 0; i < N; i++) {
      StdOut.println(randomString(L, alpha));
    }
  }
}
```

이 프로그램은 랜덤 문자열 생성을 위한 도구로, 커맨드라인 인자를 통해 문자열의 개수, 길이, 사용할 문자 집합을 받아 무작위로 문자열을 생성한다.
randomString 메서드는 배열을 사용해 무작위로 문자를 선택하고, 이를 문자열로 변환해 반환한다.


## 순차 탐색의 문제점

순차 검색은 단순하고 직관적인 방법이지만, 성능상 한계가 명확하다. 특히 전체 데이터와 입력 목록이 클 경우, 순차 검색을 사용하는 것은 비효율적일 수 있다.

### 시간 복잡도
`최악의 경우 시간 복잡도: O(N)`

강의에서는 순차 검색의 성능을 실제로 측정하는 테스트를 진행했고 결과는 다음과 같았다.

전체 리스트의 길이가 N이고, 10N개의 검색을 수행하는 경우:
10,000개의 항목에 대해 검색을 수행하는 데 3초가 걸렸고, 20,000개의 항목에 대해 9초가 걸렸다.
데이터 크기가 커질수록, 실행 시간이 기하급수적으로 증가함을 알 수 있었다.
만약 자신이 어떠한 프로그램을 만들고 고객을 약 100만명 정도 유치하기를 원했을 때 이러한 방식을 사용한다고 치면 전체 데이터를 처리하는데 약 10시간이 걸리고, 이는 초당 34건의 거래밖에 처리 못한다는 것을 의미한다.
이는 매우 비효율적이다.


# 이진 탐색

더 좋은 방법이 있다. 이진 탐색(Binary Search)은 정렬된 데이터 집합에서 특정 값을 찾기 위해 사용되는 효율적인 탐색 알고리즘이다. 
이진 검색의 핵심은 탐색 범위를 반복적으로 절반으로 줄여가며 원하는 값을 찾는 것이다. 
이를 통해 탐색 속도를 대폭 줄일 수 있다.

## 기본 개념
**정렬된 배열을 전제**로 작동한다. 이는 이진 검색이 작동하기 위한 기본 조건이다. 배열의 중간 값을 기준으로, 찾고자 하는 값이 중간 값보다 큰지, 작은지를 비교한다.
비교 결과에 따라 탐색 범위를 절반으로 줄여 다시 검색을 진행한다.

## 탐색 과정
먼저 중간 값(mid)을 선택한다. 배열의 가장 낮은 인덱스(low)와 가장 높은 인덱스(high)를 사용하여 중간 값을 계산한다:

`mid = low + (high−low)/2`
​
그리고 중간 값과 비교를 하는 것이다.

- 만약 같다면, 해당 인덱스를 반환한다.
- 찾고자 하는 값이 중간 값보다 크다면 오른쪽 절반을 탐색한다.
- 찾고자 하는 값이 중간 값보다 작다면 왼쪽 절반을 탐색한다.
- 탐색 범위를 반복적으로 좁혀나가며 키 값을 찾거나, 찾을 수 없을 때 탐색을 종료한다.


## 예제 코드

``` java
public class BinarySearch {

	public static int search(String key, String[] a) {
		return search(key, a, 0, a.length) ;
	}
	public static int search(String key, String[] a, int low, int high) {
		if (high <= low) return -1;
		int mid = low + (high - low) /2;
		int cmp = a[mid].compareTo(key);
		//compareTo는 객체간의 순서를 정의하는 데 사용하는 메서드이다. 주로 정렬과 비교와 관련된 작업에 사용된다.
		//compareTo는 Comparable 인터페이스에서 제공되며, 클래스가 이 인터페이스를 구현하면 해당 클래스의 인스턴스들 간의 자연 정렬 순서를 정의할 수 있다.
		//여기서 유의해야할 점은 문자/문자열의 경우엔 ASCII코드나 UNICODE 상의 순서로 기준 삼기 때문에 사용시 유의가 필요하다.
		if (cmp > 0 ) return search(key, a, low, mid);
		else if (cmp < 0) return search(key, a, mid+1, high);
		else return mid;
	}
}
```
- 참고로, `compareTo` 메서드는 객체 간 순서를 정의하는 데 사용되며, 문자열 비교 시 유니코드 또는 아스키코드 값 기반으로 동작한다. 따라서 문자나 문자열 비교 시, 특히 비영어권 문자를 처리할 때 유니코드 순서와 사용자가 기대하는 순서가 다를 수 있으므로 유의해야 한다.


## 순차 검색과 이진 탐색의 성능 비교

**순차 검색(Linear Search**)은 배열의 모든 요소를 하나씩 확인하며 값을 찾기 때문에 시간 복잡도는 **O(N)** 이다.
**이진 탐색(Binary Search**)은 탐색 범위를 절반으로 줄여가며 진행하므로 시간 복잡도는 **O(log N)** 이다.


실제 강의상에서 경험적 테스트를 통해 순차 검색과 이진 검색의 성능을 비교했다.
이진 검색은 10만개의 수를 탐색하는 데 단 1초 밖에 걸리지 않았고, 160만의 수에도 30초밖에 걸리지 않았다.
만약 자신이 만드는 사이트에서 천만 건의 거래가 있다고 쳐도 몇 분 안에 처리할 수 있는 것이고 이는 곧 초당 5만건의 거래량을 커버할 수 있다는 것이다.


## 본질적인 문제점

이진탐색은 결국 **정렬된 데이터** 와 배열이나 arraylist 같은 **랜덤 접근**이 가능한 자료구조에만 사용 가능하다는 것이다.
또한 데이터의 크기가 매우 큰 경우, 해당 예제 코드처럼 재귀적 구현에서는 재귀 깊이 깊어질 수 있으며 이로인해 스택 오버플로가 발생할 수도 있다.

이 중 가장 큰 걸림돌은 역시 정렬된 데이터를 상정하는 문제일 것이다. 이를 해결하기 위해선 어찌해야할까?
