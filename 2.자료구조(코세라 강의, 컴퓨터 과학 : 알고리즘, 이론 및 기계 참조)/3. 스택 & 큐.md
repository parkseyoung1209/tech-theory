# 스택과 큐

스택과 큐라는 두 가지 기본적인 자료구조에 대해 이야기해 보겠다. 둘 다 상당히 기본적이면서도 실제로 다양한 프로그램에서 매우 중요한 역할을 한다.
이전 문서에서 간략히 언급했지만 더 자세히 기술하도록 하겠다.

우선 왜 이 둘을 따로 설명하지 않고 같이 묶어서 설명할까?

이 두 자료구조는 꽤나 유사한 점이 많기 때문이다. 스택과 큐는 추상 데이터 유형(Abstract Data Type)으로, 데이터의 집합과 그것을 다루는 연산을 명확하게 정의한 것이라 볼 수 있다. 이 두 구조 모두 데이터를 넣고 빼는 방식이 다를 뿐 그 메커니즘이 간단하다는 점에서 유사하다.

모든 데이터 유형은 특정한 값들의 집합을 가지고 있고, 그 값을 어떻게 다룰지 고민해야 한다. 여기서 중요한 설계 과제는 어떤 **자료구조를 사용해야 가장 효율적인가?** 라는 점이다.

이를 결정할 때 고려해야 할 두 가지 주요 요소가 있다.

첫 번째는 그 자료구조가 얼마나 많은 메모리를 사용하는지이다. 

두 번째는 그 데이터 구조를 사용할 때 각 연산이 얼마나 빠르게 수행될 수 있는지, 즉 시간적인 효율성이다. 이 두 가지 요소는 특히 많은 데이터를 다루는 프로그램을 설계할 때 중요한 기준이 되며, 어떤 자구조를 선택할지 결정하는 데 큰 도움이 된다.

## 스택

먼저 스택에 대해 살펴보자. 

스택은 데이터를 추가하고 제거하는 방식에서 "**마지막에 추가된 데이터가 가장 먼저 제거된다**"라는 LIFO(Last In, First Out) 원칙을 따른다. 

스택의 주요 연산으로는 `push`와 `pop`이 있다. `push`는 새 항목을 스택에 추가하는 작업이며, `pop`은 스택에서 가장 최근에 추가된 항목을 제거하고 그 값을 반환하는 작업이다. 이때 스택은 언제나 마지막에 들어온 항목이 가장 먼저 나간다. 예를 들어, 스택에 "A", "B", "C" 순으로 넣었다면, `pop`을 수행할 때 가장 최근에 추가된 "C"부터 제거된다. 이런 식으로 스택은 데이터를 쌓아두고, 쌓은 순서의 역순으로 꺼내는 구조이다.

좀 더 구체적으로 구현 방향성을 써보자. 그 전에 자바 예제에 나오는 제네릭(Generic)이라는 요소에 대해 설명 먼저 하겠다.

### 제네릭

제네릭(Generic)이라는 개념은 Java와 같은 프로그래밍 언어에서 코드의 재사용성을 높이고, 다양한 데이터 유형을 보다 효율적으로 다룰 수 있게 해주는 중요한 기능이다. 
좀 더 쉽게 설명하자면, 제네릭은 데이터 유형에 구애받지 않고 코드를 작성할 수 있게 해 주는 도구라고 볼 수 있다.

보통 우리가 프로그래밍할 때 특정 데이터 유형을 명확하게 정해줘야 한다. 예를 들어, int형 리스트를 만든다면, 그 리스트에는 오직 정수만 들어갈 수 있다. 그런데 만약 문자열이나 다른 유형의 데이터를 담고 싶은 경우에는 새로운 리스트를 만들어야 한다. 여기서 제네릭을 사용하면, 리스트가 어떤 데이터 유형이든 받을 수 있도록 할 수 있다. 즉, 같은 코드로 여러 유형의 데이터를 다룰 수 있게 되는 것이다.

#### 사용 예시 

ava에서는 <>를 사용해 제네릭을 선언한다. 예를 들어, ArrayList<T>와 같은 형태로 제네릭 타입을 지정하는데, 여기서 T는 "타입의 약자"로 일종의 자리 표시자 역할을 한다. 코드 작성 시에는 T 대신 정수형(Integer), 문자열(String) 같은 실제 데이터 유형을 넣어서 사용할 수 있다.

```java
// 정수형 리스트
ArrayList<Integer> intList = new ArrayList<>();

// 문자열 리스트
ArrayList<String> stringList = new ArrayList<>();
```

위 예시에서 보듯이, ArrayList<T>라는 제네릭 타입 덕분에 우리는 리스트를 정수형으로도, 문자열형으로도 만들 수 있다. 만약 제네릭이 없다면, 각각 ArrayListInt, ArrayListString 같은 다양한 리스트 클래스를 만들어야 했을 것이다. 제네릭을 사용함으로써 코드가 훨씬 더 간결하고 재사용 가능하게 된다.

##### 추가 개념 : Wrapper

여담으로, Integer 같은 데이터 유형을 '래퍼(Wrapper)'라고 하는데 기본 자료형을 객체화 시킬 수 있는 클래스라고 생각하면 된다.

자바는 기본적으로 객체지향 언어이므로, 기본 자료형조차 객체로 다루어야할 상황이 매우 많은데 이를 위하여 만들어진 것이다.

현재의 자바에선 오토 박싱과 언박싱이라는 개념이 있는데 이는 기본 자료형과 래퍼 클래스 간의 변환을 컴파일러가 자동으로 수행해주는 것을 의미한다.

```
오토 박싱은 기본 자료형 -> 래퍼 클래스

언박싱은 래퍼 클래스 -> 기본 자료형
```

이를 통해 사용자가 특별히 데이터 타입을 따로 캐스팅 할 필요가 없어진다.

이 항목에서 래퍼 클래스를 간단하게라도 아는게 중요한 이유는 **우리가 자바를 이용해 ADT를 커스텀으로 구현하든 자바 컬렉션을 사용하든 제네릭 타입 지정은 이 래퍼 클래스로만 해야하기 때문이다.**


### 스택의 구체적 구현 방향성

``` java
public class Stack<Item>

Stack<Item>(); : 모든 타입에 대한 데이터들로 구성될 수 있는 스택이 구현되어야 함
void push(Item item); : 데이터 추가
Item pop(); : 가장 최근에 push된 데이터를 제거하고 그 데이터를 리턴해야한다.
boolean isEmpty() : 말 그대로 스택에 비었는가를 판단
int size() : 현재 스택의 크기
```

스택이란 개념 자체는 매우 추상적이기에 실제 코드로 구현하기 위해서 이같은 지침이 우리에겐 필요하다.(실제로 부가적인 메서드 구현을 해도 스택의 본질만 해치지 않으면 무방하다.) 물론 저 메서드 중에서 제일 중요한건 후입후출의 원칙의 근간인 push와 pop의 구현이다.

## 큐

이제 큐에 대해 이야기해 보자. 

큐는 스택과 유사하지만, 데이터를 추가하고 제거하는 규칙이 조금 다르다. 

큐는 "먼저 들어온 데이터가 먼저 나간다"라는 FIFO(First In, First Out) 원칙을 따른다. 대기열을 생각하면 쉽다. 

큐의 주요 연산으로는 `enqueue`와 `dequeue`가 있다. `enqueue`는 큐의 끝에 새 항목을 추가하는 연산이며, `dequeue`는 큐의 앞부분에서 가장 오래된 항목을 제거하고 그 값을 반환하는 연산이다. 예를 들어, 큐에 "A", "B", "C" 순으로 넣었다면, `dequeue`를 수행할 때 가장 처음에 들어온 "A"부터 제거된다. 이렇게 큐는 데이터를 순서대로 처리하는 데 유용하다.

### 큐의 구체적 구현 방향성

``` java
public class Queue<Item>

Queue<Item>(); : 모든 타입에 대한 데이터들로 구성될 수 있는 큐 구현되어야 함
void enqueue(Item item); : 데이터 추가
Item dequeue(); : 가장 먼저 enqueue된 데이터를 제거 및 리
boolean isEmpty() : 말 그대로 스택에 비었는가를 판단
```

마찬가지로 큐란 개념 자체는 매우 추상적이기에 실제 코드로 구현하기 위해서 이같은 지침이 우리에겐 필요하다.(실제로 부가적인 메서드 구현을 해도 큐의 본질만 해치지 않으면 무방하다.) 물론 저 메서드 중에서 제일 중요한건 선입선출의 원칙의 근간인 enqueue와 dequeue의 구현이다.


## 더 자세히

값들이 모두 같은 유형으로 이루어진 항목들의 집합을 **컬렉션** 이라고 해보자. 예를 들어, 정수들만 모아놓은 리스트나 문자열들만 모아놓은 배열 같은 것이다.
또한 이런 식으로 값들이 모두 같은 유형의 항목들로 이루어진 컬렉션은 "멀티셋"이라고 부를 수 있다. 여기서 멀티셋이란, 중복된 값들을 포함할 수 있는 집합을 의미하는 것이다.

결국 이와 같은 개념을 가지고 여러 기본적인 자료구조가 만들어지는 것이다. 위에서 서술한 스택과 큐에 대해서 생각해보자.

이 두 자료구조는 데이터의 모임이라는 점에서 기본적으로 유사하지만, 데이터를 넣고 빼는 방식의 "작업 규칙"에서 차이가 있다. 즉, 스택은 마지막에 들어온 것을 먼저 빼는 반면, 큐는 먼저 들어온 것을 먼저 빼는 식으로, 데이터 처리 방식만 다르다. 이런 차이 때문에 작업 사양(작업을 처리하는 방법)에 있어 세부적인 차이가 있을 뿐, 기본적으로는 유사한 자구조라고 할 수 있는 것이다.

다른 중요한 점은 스택과 큐 모두 정의상, 미리 정해진 크기의 제한이 없다는 것이다. 이는 프로그램의 입장에서 보면 이는 메모리의 제약에 얽매이지 않고 유연하게 데이터를 관리할 수 있음을 의미한다. 컴퓨터가 점점 더 많은 데이터를 처리할 수 있도록 설계할 때 유용하다.

## 중요한 것은 제대로 된 구현

마지막으로, 이러한 데이터 구조를 설계할 때 중요한 고려 사항이 있다. **바로 성능이다.** 
스택이나 큐를 사용할 때, 모든 연산은 가능한 한 일정한 시간 내에 이루어져야 하며, 메모리 사용도 효율적이어야 한다. 
스택에 몇 개의 항목이 있느냐에 따라 메모리가 선형적으로 증가하고, 모든 연산이 일정한 시간 안에 끝나야 비로소 "진정한" 스택이나 큐라 할 수 있다. 
이러한 성능 요구사항을 충족하지 못하면, 그것은 스택이나 큐의 이름을 붙이기에는 적합하지 않은 것이다.

예를 들어 상단에 적은 스택과 큐의 구현 방향 지침을 어찌저찌 구현했다고 했다고 치자. 그러나 우리는 구현에 대해 더 강력한 기준으로 성능을 삼는다.
이러한 성능 사양을 충족하지 못하면 진정으로 스택과 큐라는 추상 데이터 타입에 대한 구현을 했다고 볼 수가 없다.


## 유용성

자료구조의 추상적인 개념 그 자체만큼 어려운 것은, '이 자료구조를 실제로 어떻게 쓸까?' 라는 고안 하는 것이다.

큐(queue)와 스택(stack) 자료구조의 유용성을 설명하기 위해 몇 가지 예시를 이야기하려 한다. 이러한 자료구조는 프로그래밍에서 매우 중요한 역할을 한다.

큐의 응용은 매우 다양하다. 예를 들어 데이터 전송, 표준 입력, 표준 출력과 같은 곳에서도 큐를 사용한다. 컴퓨터 시스템 내에서 공유 리소스를 사용할 때에도 큐가 사용된다. 이는 현실 세계에서도 마찬가지로, 줄을 서서 기다리는 사람이나 차량처럼, 선착순으로 리소스를 제공하는 상황에 큐를 활용할 수 있는 것이다.

스택(stack)의 응용은 프로그래밍 언어의 기법에서 매우 다양하게 사용된다. 대표적인 예시로 함수 호출에서도 스택이 중요한 역할을 한다. 재귀 호출에서는 마지막으로 호출된 함수부터 다시 돌아가게 되며, 이 과정에서 스택이 사용된다.
좀 더 우리에게 친숙한 예제로는 웹을 탐색할 때이다. 우리는 페이지를 방문할 때 다른 페이지로 연결되는 링크를 클릭하고 다른 페이지로 연결되는 링크를 클릭하게 되는데, 실제 시스템이 수행하는 작업은 사용자가 방문한 링크를 스택에 저장하는 것뿐이다.
여기서 뒤로 가기 버튼을 클릭하면 스택이 팝업되어 가장 최근에 방문한 페이지로 이동하게 된다.

**이를 통해 보았듯이 큐와 스택 모두 컴퓨터 시스템과 프로그래밍 언어에서 근간이 되는 메커니즘 구현을 도와주고 컴퓨팅의 매우 기본적인 추상화를 제공한다.**

좀 더 구체적으로 보자.

### 큐를 이용한 동적 문자열 배열 만들기

큐를 사용하면 표준 입력의 모든 문자열을 배열에 넣는 등의 작업을 쉽게 처리할 수 있다. 큐에 문자열을 차례로 추가하고, 배열의 크기를 동적으로 결정하여 이를 배열에 복사하는 방식으로 구현할 수 있다. 

구체적인 예시 코드를 써보겠다.

``` java
public class QEx {
  public static String[] readAllStrings() {
    Scanner sc = new Scanner(System.in);
    Queue<String> q = new Queue<String>();
    // 여기서 사용된 큐는 자바 컬렉션을 사용한 큐가 아니라 실제 사용자가 만든 큐 클래스를 사용했다고 생각하면 된다.
    while(sc.hasNextLine()) {
      q.enqueue(sc.nextLine());
    }
    int N = q.size();
    String[] words = new String[N];
    for(int i = 0; i < N; i++) {
      words[i] = q.dequeue();
    }
    return words;
  }
  public static void main(String[] args) {
    String[] words = readAllStrings();
    for(int i = 0; i < words.length; i++) {
      System.out.println(words[i]);
    }
  }
}
```

큐를 이용해 입력받은 문자열을 데이터의 수에 상관없이 배열애 담을 수 있는 동적인 스트링 타입 배열을 만들어봤다.

물론 이 코드는 입력의 한계를 특정해놓지 않았기에 실제로 사용하면 문제가 생기겠지만 이는 사용자의 필요성에 따라 간단히 커스텀하면 그만인 문제이다.

### 스택을 이용한 Postfix 표현식 구현

먼저 Postfix 표현식이 뭔지부터 설명을 하겠다. 우리가 흔히 아는 산술 표현식(중위 산술 표현식)은 다음과 같다.

```
(1+((2+3)*(4*5)))
```

즉 어떠한 복합적인 연산을 할 때 특정 연산의 순서를 지정하고 싶다면 괄호를 사용하여 표현하는 것이다. 이를 Postfix로 표현하면 다음과 같다.

```
1 2 3 + 4 5 * * +
```

이게 대체 뭔 말인가 싶을 수 있다.. 하지만 이해를 하는 순간 상당히 간결한 표현이라고 생각이 들 것이다.
먼저 숫자가 순서대로 하나씩 하나의 블럭에 쌓인다고 생각해보자. 그러면 1 - 2 - 3 순서대로 쌓일 것이다.
그 다음엔 '+' 연산자를 만나게 된다. 이건 어떻게 될까?
이 연산자는 해당 숫자 블럭의 가장 최근 요소 두개를 피연산자로서 계산한다. 그 후에 결과값을 다시 블럭에 넣는다.
즉 이 단계에서 저 식은 다음과 같이 변한다.

```
1 (2+3) 4 5 * * + -> 1 5 4 5 * * +
```

요컨데 해당 숫자 블럭의 가장 최근 요소 두 개를 피연산자 삼아 임의의 연산자에 따라 순서대로 계산을 하는 식이다.

결국 이러한 표현식으로 연산을 실행하면 다음과 같다.

```
1 5 (4*5) * + -> 1 5 20 * + -> 1 (5*20) +
= 1 + 100
= 101
```

Postfix라는 표현식의 가장 좋은 점은 괄호가 없다는 것이다. 이 단순한 장점 하나가 휴대용 계산기의 기초로 사용되기도 하고 초기 컴퓨터 설계나 자바 가상 머신을 구성하는 **스택 기반 연산**의 근간으로서 사용되었다.

즉 우리는 Postfix 표현식을 스택 기반으로 구현하는 것이다.

``` java
public class Postfix {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    Stack<Double> stack = new Stack<Double>();
    while (sc.hasNextLine()) {
      String token = sc.nextLine();
      if(token.equals("*")) stack.push(stack.pop() * stack.pop());
      else if(token.equals("+") stack.push(stack.pop() + stack.pop());
      else if(token.equals("-") stack.push(-stack.pop() + stack.pop());
      else if(token.equals("/") stack.push((1.0/stack.pop()) * stack.pop());
      else if(token.equals("sqrt") stack.push(Math.sqrt(stack.pop())); // 루트 구하기
      else stack.push(Double.parseDouble(token));
    }
  System.out.println(stack.pop());
  }
}
```

여기서 유의해야할 점은 뺄셈과 나눗셈인데, 스택은 가장 최근 것을 우선적으로 빼오기 때문에 **단순히 '피연산자 a' - '피연산자 b' 같은 메서드로 구현을 하면 안된다.**

즉 5 - 3 이라는 식을 구현하려면 가장 최근 요소인 3을 -3으로 치환시키고 -3 + 5로 생각해야 실제 순서 상 5 + (-3) -> 5 - 3으로 구현된다.


실제로 우리는 단순히 계산기를 사용하던 코딩을 하던, 중위 산술 표현식을 컴퓨터에게 입력하게 된다. 이를 컴퓨터가 처리를 하려면, 두 개의 스택을 이용하여 구현한다.

이러한 표기법 변환을 위한 알고리즘도 존재한다고 하지만 여기서까지는 서술하지 않겠다...

다만 이러한 변환 알고리즘을 이용하는 것부터 그렇고, 자바 컴파일러가 괄호의 구분을 할 때도 그렇고 심지어 스 코드를 읽고 이를 컴퓨터가 실행할 수 있는 기계어 코드로 변환하는 과정에서 스택은 매우 중요한 도구가 된다는 사실은 알아둘만하다.


### 스택 api 배열 구현

우리는 스택 그 자체도 구현을 할 줄 알아야한다. 해당 예제 코드는 배열을 이용한 스택 구현이다.

``` java
public Class Stack {
  private String[] a;
  private int N = 0;

  public Stack(int num) {
    a = new String[num];
  }
  public boolean isEmpty() {
    return (N == 0) ;
  }
  public boolean push(String item) {
    a[N++] = item;
  }
  public String pop() {
    return a[--N];
  }
  public int size() {
    return N;
  }
}
```

생각보다 훨씬 간단한 예제이다. 다만 옳지 못한 예제일 뿐.

스택이 진정으로 요구하는 성능 사양에 대해 다시 생각해보자. 먼저 스택은 추상적으로 용량의 제한이 없어야한다. 허나 이 스택 api는 사용자가 용량을 별도로 지정해주어야한다.

물론 현실의 프로그래밍은 이론만으로는 해결이 되지 않아 저러한 경우가 있긴 하나 충족을 못한다는 점에선 엄밀한 사실이다.

사실 이보다 훨씬 중요한 사실은, **이 스택은 결국 String에서만 작동한다. 우리는 모든 타입에서 돌아가는 스택을 원하는데 이는 명백한 오류이다.**

그 밖에도 해당 코드의 pop() 메서드는 어디까지나 결과값을 리턴만 할 뿐 해당 스택에서 마지막 데이터를 제거하지는 않는다.
(만약 온전한 push 메서드를 구현하려면 데이터를 별도의 스트링 데이터로 지정하고 해당 인덱스의 값에 null을 넣으면 된다.)

그럼 저러한 문제들을 어떻게 해결할까?


### 연결 리스트를 이용한 스택과 큐 구현

스택과 큐를 구현하는 데 사용할 새 자료구조는 연결 리스트이다. 이는 많은 종류의 응용 프로그램에서 사용되는 기본 자료구조로, 이 구조를 통해 문제를 해결할 수 있다. 

중요한 것은 데이터를 보관하기 위한 **순차 메모리 할당과 연결 할당**의 차이를 이해하는 것이다. 

순차 자료구조는 배열로, 모든 객체가 메모리에 연속적으로 저장되는 방식이다. 반면, 연결된 자료구조에서는 각 객체가 다음 객체에 대한 링크를 갖고 있으며, 이러한 링크는 다른 객체의 메모리 주소를 나타낸다.

Java에서는 이를 레퍼런스(참조)라고 하며, 연결리스트 이러한 레퍼런스를 사용해 여러 노드들이 서로 연결되는 구조이다. 연결 목록은 배열과 달리 크기가 고정되지 않고 유연하게 노드를 추가하거나 제거할 수 있다.

연결 목록은 **재귀적 자료구조**로 생각할 수 있다. 즉, 연결리스트는 null이거나 노드에 대한 참조이고, 노드는 데이터를 저장하며 다음 노드에 대한 참조를 가진다. 

먼저 이해하기 쉽게 노드를 자바 코드로 구현해보겠다.

``` java
private Class Node {
  private String item;
  private Node next;
}
```

이 간단한 구조가 매우 많은 프로그램에서 응용된다. 실제 데이터와 다음 노드를 참조할 Node 타입의 next만이 조재한다.

이를 이용해 각각의 데이터를 어떻게 연결 시키는지도 보자.

``` java
Node third = new Node();
third.item = "철수";
third.next = null;

Node second = new Node();
second.item = "영희";
second.next = third;

Node first = new Node();
first.item = "길동";
first.next = second;
```

막상 구현해보면 매우 심플하다. 마지막에 위치한 노드의 다음 참조를 null로 지정해 다음 데이터가 없다는 것을 설정하고, 퍼스트 노드의 다음 노드 참조를 세컨드, 세컨드 노드의 다음을 서드로 지정했을 뿐이다.

물론 이렇게 노드를 일일이 지정해서 리스트를 구현해도 문제가 있다고 할 수는 없지만, 이미 자바가 생겨나기도 전에 훨씬 나은 방법론들이 생겨난 마당에 저런 코드는 거의 쓰이지는 않는다.

그럼에도 쉬운 이해를 위해 저 코드를 응용한 첫자리 노드 삭제, 시작 지점에 추가, 그리고 전체 순회 코드도 적어보겠다.

``` java

// 삭제
first = first.next;

// 추가

Node second = first;
first = new Node();

first.item = item;
first.next = second;

// 전체 데이터 출력

Node x = first;
while (x != null) {
  System.out.println(x.item);
  x = x.next;
}
```

삭제는 기존 노드를 다음 노드를 가리키게 하면 기존의 노드는 해당 데이터를 가지게 된다.

추가는 기존 노드를 두번째 노드에 넣고, 첫번째 노드를 새로운 노드로 재구성 시킨 뒤 실제 데이터를 넣고 다음 노드를 참조시키면 된다.

전체 데이터를 출력할 시에는 삭제를 응용하여 해당 노드의 다음 노드를 계속 자기 자신으로 바꾸어 각각의 데이터를 출력시키면 그만이다.


사실 상단의 코드들은 조금만 생각해봐도 실제로 사용하면 논리적 오류가 많고 가독성도 떨어지고 메모리도 많이 먹을 것이다. 실제로 연결 리스트의 구현은 좀 더 제대로 구현을 해야한다.

``` java
// 첫번쨰 노드에 입력받은 새로운 데이터들이 계속 추가되고 출력

public class List {
  public Class Node {
    public String item;
    public Node next;
  }
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    Node list = null;
    while(sc.hasNextLine()) {
      Node old = list;
      list = new Node();
      list.item = sc.nextLine();
      list.next = old;
    }
    while(list != null) {
      System.out.println(list.item);
      list = list.next;
    }
  }
  // 끝 노드에 데이터 추가
  ...
  Node list = new Node();
  list.item = sc.nextLine();
  Node last = list;
  while (sc.hasNextLine()) {
    last.next = new Node();
    last = last.next;
    last.item = sc.nextLine();
  }
  ...
}
```

실제로는 이런식으로 반복문을 이용하거나 재귀하여서 구현한다. 그리고 이러한 구현은 확장되어 **스택과 큐의 구현**에 응용된다.

다음은 실제로 연결리스트를 이용해 구현한 스택이다.

``` java
public class Stack<Item> {
  private Node first = null; 
  private int N = 0;

  private class Node {
    private Item item;
    private Node next;
  }

  public boolean isEmpty() {
    return first == null;
  }

  public void push(Item item) {
    Node second = first;
    first = new Node();
    first.item = item;
    first.next = second;
    N++;
  }
  public Item pop() {
    Item item = first.item;
    first = first.next;
    N--;
    return item;
  }
  public int size() {
    return N;
  }
}
```

여기서 우리가 간과하지 말아야할 것은 이것은 스택이다. 연결리스트의 첫번째 노드에 데이터가 추가된다는 말이 **스택에 추가된 데이터들이 첫번쨰 요소**로서 있는 것이 아니란 말이다.

간단히 생각했을 때 오른쪽에서 왼쪽으로 쌓이는 블럭을 스택이라고 생각한다면 해당 코드가 매우 쉽게 이해될 것이다.

그 다음은 큐 구현이다.

```java
public class Queue<Item> {
  private Node first = null;
  private Node last = null;
  private int N = 0;
  
  private class Node {
    private Item item;
    private Node next;
  }

  public boolean isEmpty() {
    return first == null;
  }

  public void enqueue(Item item) {
    Node oldLast = last;
    last = new Node();
    last.item = item;
    last.next = null;

    if(isEmpty()) {
      first = last;
    } else {
      oldLast.next = last;
    }
    N++;
  }
  /* 노드를 하나만 사용한다면?
    public void enqueue(Item item) {
    Node second = new Node();
    second.item = item;
    second.next = null;
    
    if(isEmpty()) first = second;
    else {
      Node current = first;
      while(current.next != null) {
        current = current.next;
      }
      current = second;
    }
    N++;
  }
  */

  public Item dequeue() {
    if(isEmpty()) return null;
    
    Item item = first.item;
    first = first.next;
    N--;
    
    if(isEmpty()) {
      last = null;
    }
    return item;
  }
  public int size() {
    return N;
  }
}
```

스택과 흡사하면서도 근본적인 차이가 존재한다. 효율성을 위해 노드를 2개 사용하여 구현한다는 것이다.
해당 코드에는 노드를 하나만 사용하여 반복문으로 끝에 추가하는 방식과 노드 두 개를 이용하는 방식 두가지가 있다.

여기서 권장되는 것은 후자인데, 시간복잡도 상 큐의 추가는 상수 시간이 실행되어야한다.
헌데 반복문을 통해 기존 리스트의 끝까지 가는 로직 자체에 O(N)의 시간이 걸리기 때문에 매우 비효율적이다.

이 외의 메서드 구현은 마치 스택을 복붙한 것과 마찬가지 수준으로 구현했다.


## 결론

결국 초기에 언급한 근본적인 작동원리, 즉 **선입선출과 후입후출의 차이** 가 둘의 차이를 만든다는 것이다.

이를 반대로 이야기하면, 거의 비슷한 이 자료구조의 특성을 간과하고 스택보단 큐에 가까운 자료구조를 구현했으면서 실제 스택처럼 사용을 하려고 한다면 크나큰 문제가 일어날 수도 있다는 점을 시사한다.

또한 배열을 사용하는 것이 아닌, 연결 리스트라는 또 다른 자료구조의 활용으로 스택과 큐 같은 추상적인 데이터 구조를 구현할 때, 배열의 한계로 인해 유연하지 못한 문제를 연결 리스트를 이용해 해결할 수 있었다.

특히 이론적으로 용량에 제한이 없어야하는 스택과 큐의 특성상 연결 리스트의 유연성은 **크기 문제나 삽입/삭제** 문제를 효율적으로 해결했다.

다만 해당 연결리스트는 단점도 명확한 자료구조인데 이를 개선한 이중 연결 리스트나 원형 연결 리스트 같은 자료구조도 존재한다.

특히 이중 연결 리스트는 향후 다른 문서에서 후술할 **심볼 테이블** 이라는 자료구조에 사용될 것이다.(강의상에서는 이렇게 쓰여졌지만 실제로는 Map 자료구조와 구체적인 구현 방법 중 하나인 이진 탐색 트리를 설명하는 것이다.)
