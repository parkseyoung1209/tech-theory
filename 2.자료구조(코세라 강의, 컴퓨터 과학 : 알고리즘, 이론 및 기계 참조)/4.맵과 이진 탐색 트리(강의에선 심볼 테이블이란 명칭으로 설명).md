# 맵

우선 우리는 선형적인 자료구조에서 유용하게 쓸 수 있는 이진 탐색과 병합 정렬이라는 유용한 알고리즘을 알게되었다. 
이를 통해 우리가 실제 서비스를 만든다고 할 때, 더욱 더 빠른 검색이 가능할 것이다. 다만 **기존의 데이터에 한해서**


즉 새로운 데이터가 추가될 때, 혹은 기존의 데이터를 갱신하는 경우 **전체 목록을 다시 정렬하고 갱신하는 것이 필요하게된다.**
이건 간단히 생각해봐도 매우 불편하고 시간이 오래 걸린다. 만약 데이터의 추가 삭제가 빈번한 서비스에선 큰 비용이 들 수 밖에 없을 것이다.

따라서 이 문제를 해결하기 위해선 더욱 유연한 새로운 자료구조가 필요하다. 우리가 곧 알게 될 **맵**(**Map**)이라는 자료구조가 바로 이러하다. 

## 맵이란 무엇인가?

먼저 우리가 겪는 문제를 좀 더 구체적으로 다루어보자. 다시 말하지만, 우린 이미 정렬된 리스트 혹은 배열에 관해서는 상당한 유연성을 가지고 있다.
문제는 **추가, 수정, 삭제**이다. 이는 마치 종이로 인쇄된 전화번호부가 겪는 문제와 비슷한데 예를 들어, 전화번호부에서 이름에 맞는 번호를 변경하고 싶다면 기존 전화번호부에는 그런 기능이 없어서 다음 해에 새로운 전화번호부가 인쇄될 때까지 기다려야만한다...

물론 우리는 현대의 디지털 시스템에 자리잡고 있고 코딩은 실제 메모리가 뒷받침되는 한 공간은 추가확장할 수 있기 때문에 기존의 종이 전화번호부처럼 '불가능'의 영역까진 아니다.
하지만 계속 반복해서 말하듯이, 우리는 **구현 그 자체에 만족을 해선 안된다는 것이다.**

이를 성능적으로도 만족할만한 자료구조가 바로 맵이다. 맵은 키-값 쌍을 저장하고 검색하는 ADT이다. 사실 개념 자체는 매우 심플하다.
위에서 언급한 전화번호부를 떠오르면 이해가 쉬운데, 전화번호부 좌측의 임의의 이름이 존재하고, 우측에는 그 사람의 전화번호가 존재한다.
여기서 이름이 키가 되는 것이고 값(밸류)은 전화번호가 되는 것이다.

결국 이 단순한 특성을 정적인 종이 전화번호부가 아닌 확장가능한 디지털 시스템에 적용시킨 것에 불과하다.

맵은 키를 통해 값에 접근하는 방법을 제공하고, 스택과 큐에서 그랬듯이 둘 다 어떠한 데이터 타입이든 가능해야한다.

우리가 기존에 알고있던 배열을 생각해보면 배열은 고정된 인덱스를 통해 접근이 가능했다. 맵은 그 키가 인덱스 역할을 대신한다고 보면 된다.
또한 배열은 한정된 크기를 가진 반면, 맵은 이론상 그 크기가 무한하다. 

**즉 임의의 데이터 접근에 리스트보다 훨씬 빠른 속도를 가지면서도 연결리스트처럼 확장 가능하다는 것이다.**

## 더 자세히

맵 자체는 추상 자료 구조이기 때문에 사용 언어에 따라 구현이 다를 것이다. 가장 간단하게 코드로 구현해보자면 이렇게도 쓸 수 있다.

``` python
phonebook["Alice"] = "123-456-7890"
```

비록 나는 파이썬을 아직 공부하지 않았지만, 이 코드를 이해하는데 문제가 전혀 지장이 없을 정도다. 키 값을 엘리스로 지정하고 앨리스의 밸류를 전화번호로 가지게끔 하는 방식이다.
물론 **자바에서는 이런 간단한 구현은 어림도 없는 일이다...** 과연 어찌 구현해야할까?

구체적 구현의 방향성을 정해보도록 하자.

**1. 기본적으로 모든 키는 고유하다.**

즉, 같은 키를 여러 번 사용할 수 없으며, 동일한 키를 추가하려고 하면 기존의 값이 갱신되는 식으로 작동하게 된다. 다만 이러한 가정이 항상 엄격하게 적용될 필요는 없다.

이는 우리가 응용 프로그램에서 다룰 때 필요에 따라 다르게 구현할 수 있는데 예를 들어 수강생이 듣는 과목이라는 걸 생각해보자.

특정 학생이 듣는 과목이 3개라고 가정했을 때, 특정 학생을 키값으로 잡는 맵을 구현할때 기존의 키 고유성을 그대로 지키면 어떻게 될까?
계속 과목이 갱신만 되는 어처구니없는 상황이 발생할 것이다. 따라서 우리는 좀 더 유연하게 생각해야한다.

**2.기본 연산**

매우 당연한 말이지만, 맵의 기본 연산은 주어진 키와 값을 연결하는 것에 의의가 있다. 이를 두 가지 경우로 나눌 수가 있는데 다음과 같다.
- 키가 맵에 없는 경우 새로운 키-값 쌍을 맵에 추가하면 된다.
- 이미 존재하는 키를 입력받은 경우 기존의 키와 연결된 값을 갱신하면 된다.

**3. 값을 반환도 해야한다.**

또 다른 기본적인 작업은 주어진 키를 지정했을 때 값을 반환하는것이다. 
임의의 키가 맵에 존재하는지 확인하고 있다면 그에 해당하는 값을 반환해야만 한다. 만약 해당 키가 없다면 null을 반환하거나 임의의 값을 반환하도록 구현할 수도 있다.

**4. 추가적으로 키에 대한 비교도 필요할 수 있다.**

가끔은 키들을 순서대로 정렬할 수 있는 기능을 상정해야하기도 한다. 예를들어, 키들이 정수, 문자열, 날짜 등의 형태라면 이를 크기 순서대로 비교하고 정렬이 가능할 것이다.
이러한 정렬을 지원하는 경우, 맵을 통해 데이터를 정렬된 순서로 순회하거나 특정 조건에 맞는 데이터를 빠르게 찾을 수 있게 된다.

**5. 유연한 크기와 제네릭 사용**

구현 시, 스택과 큐에서 언급한 제네릭을 사용해서 다양한 데이터 타입에서도 작동이 가능한 맵을 구현해야할 것이다.
또한 우리는 키 - 값으로 이루어진 쌍이 계속 추가될 수 있게 용량에 한계를 두어서는 안된다.


해당 개념들을 이용해 실제 API를 구현한다면 이렇게 짜볼 수 있을 것이다.

``` java
public class ST<Key extends Comparable<Key>, Value> //  키에 대한 비교를 가능케함 compartTo() 메서드 구현 필요.
St<Key, Value>() // 생성자
void put(Key key, Value val) // 추가 put 메서드
Value get(Key key) // 가져오기 get 메서드
boolean contains(Key key) // 포함여부 묻기
Iterable<Key> keys() // 맵의 모든 키에 접근
```

해당 강의에서는 나오지 않았지만 맵의 크기를 살펴보거나 특정 키를 삭제하는 메서드 역시 구현해야할 것이다.

또한 클래스에서 `public class ST<Key extends Comparable<Key>, Value>` 부분에 대해 설명을 해보겠다.

### public class ST<Key extends Comparable<Key>, Value>의 의미

기본적으로 맵을 구현할 때는 키(Key)에 대해 비교가 가능하게 하여 정렬하거나 특정 키를 찾는 연산을 수행할 수 있게 해야한다.

**Key extends Comparable<Key>**라는 표현은 **제네릭 타입의 키(Key)**가 Comparable 인터페이스를 구현해야 한다는 뜻이다.

이는 키로 사용되는 데이터 타입은 다른 키와 비교할 수 있어야 한다는 요구사항을 의미한다.
Comparable<Key> 인터페이스를 구현하면, 키들을 정렬하거나 특정 순서대로 처리할 수 있는 기능을 제공하게 된다. 이 기능은 맵에서 데이터를 관리하거나, 검색할 때 매우 중요하게 사용된다.

중요한것은 맵이란 것을 직접 구현할 때 키로 오는 타입은 **Comparable을 반드시 구현해야한다는 사실이다.**

예를 들어, ST<Integer, String> 이라는 맵을 만들 때 Integer 클래스는 이미 Comparable<Integer>를 구현하고 있기 때문에 별도의 구현 없이 사용이 가능하다.
(물론 해당 강의는 정말 어떠한 메서드나 타입도 구현이 안되어있고 직접 구현한다는걸 상정하기에 강의상의 세상에선 integer도 우리가 직접 구현하냐마냐를 따질것이다...)
그런데 만약 ST<Custom, String> 이라는 맵을 만든다면 해당 'Custom' 타입은 Comparable을 직접 구현해야한다는 것이다.


이것 외에는 대부분이 직관적으로 이해가 될 것이다. 문제의 메서드는 `Iterable<Key> keys()` 이다. 다른걸 떠나서 대체 `Iterable`이 무엇일까..?
본격적인 구현에 앞서 이 개념을 알고 가자.


### 이터레이션

**이터레이션**은 프로그래밍에서 **컬렉션 또는 여러 개의 데이터 요소들**을 반복적으로 하나씩 접근하여 작업을 수행하는 과정을 의미한다. 
쉽게 말해, 이터레이션은 목록이나 자료구조에 있는 모든 요소들을 순서대로 처리하는 작업이라고 볼 수 있다.

여기서 컬렉션은 사실상 자료구조라고 생각해봐도 무방하다. 
이터레이션은 이러한 컬렉션의 요소들을 하나씩 차례대로 접근하여 읽거나, 변경하거나, 특정 작업을 수행하는 것 그 자체를 말하는 것이다. 
사실 우리는 웬만해서 한 번 쯤은 이터레이션 작업을 해봤다고 할 정도로 익숙한 개념이다.

당장 반복문을 이용해서 특정 배열의 모든 요소들을 출력하는 코드를 생각해보자. 이게 이터레이션 작업 중 하나인 것이다.

자바에서는 컬렉션의 요소들을 반복적으로 처리할 수 있는 다양한 방법을 제공한다.

1. for-each 구문

for-each 구문은 컬렉션에 있는 모든 요소에 접근하기 위해 자주 사용하는 방법이다.
이 방식은 자바에서 간단한 이터레이션을 제공하여, 컬렉션의 내부적인 구현을 신경 쓰지 않고도 모든 요소를 쉽게 접근 가능하다.

예제 코드

``` java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
for (String name : names) {
    System.out.println(name); 
}
```

2. Iterator 인터페이스

자바에서는 이터레이션을 보다 유연하게 처리하기 위해 Iterator 인터페이스를 제공한다.
**Iterator**를 사용하면 컬렉션의 요소를 직접 접근하거나, 특정 요소를 삭제하는 등의 작업을 보다 세밀하게 수행할 수 있다.

예제 코드

```java
List<String> fruits = new ArrayList<>();
fruits.add("Apple");
fruits.add("Banana");
fruits.add("Cherry");

Iterator<String> iterator = fruits.iterator();
while (iterator.hasNext()) {
    String fruit = iterator.next();
    System.out.println(fruit);
}
```

3. Iterable 인터페이스

자바의 Iterable 인터페이스는 컬렉션이 반복 가능한 객체임을 나타내기 위해 사용된다.
이 인터페이스를 구현하는 클래스는 상단에서 언급한 for-each 구문을 통해 반복이 가능하게 된다.
모든 컬렉션 클래스(List, Set, Queue 등)는 기본적으로 Iterable 인터페이스를 구현하고 있어, for-each 구문으로 이터레이션이 가능하다.


즉 Iterable<Key> keys() 메서드는 사용자에게 맵의 모든 키를 쉽게 반복적으로 접근할 수 있도록 도와주는 기능을 제공하는 것이다.

이 메서드를 사용하면 모든 키에 대해 순회할 수 있기 때문에, 맵에서 모든 키를 하나씩 꺼내 작업을 수행해야 할 때 유용하다.

다음과 같은 예제를 보면 바로 이해가 될 것이다.

```java
ST<String, Integer> symbolTable = new ST<>();
symbolTable.put("Alice", 1);
symbolTable.put("Bob", 2);
symbolTable.put("Charlie", 3);

for (String key : symbolTable.keys()) {
    System.out.println("Key: " + key + ", Value: " + symbolTable.get(key));
}
```

이 코드는 해당 메서드를 호출하여 반환된 Iterable 객체를 통해 맵의 모든 키를 순회하고 각 키를 꺼내면서 그에 해당하는 값을 get() 메서드를 사용하여 출력한다.

해당 메서드의 본질은 실제 사용자가 키를 정수형 타입이든 문자열 타입이든 비교 가능한 요소로 지정하는 경우가 있을터인데, 이는 곧 **키에 대한 정렬과 빠른 탐색**이 요구되는 작업 역시 불가피하다는 것이다.
모든 키에 대한 접근은 우리가 기존에 배운 정렬과 탐색 알고리즘을 가능케 해준다.


## 어떻게 사용을 할까?

- 주의점
  - 해당 예제 코드에서 나오는 입력 로직은 실제로는 이미 존재하는 유한한 데이터들이 해당 메서드에 입력된다는 전제하에 구축된다.
  - 실제로 이 예제를 사용한다면 해당 클래스에 나오는 스캐너 코드는 어느정도 다른 입력을 상정하여 수정을 거쳐야 할 것이다.

### 문자열 정렬

간단한 클라이언트 예제로는 문자열을 정렬하여 출력하는 기능 생각할 수도 있다. 다음은 예제 코드다.

```java
public class Sort {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    // Sort lines on StdIn
    BST<String, Integer> st = new BST<String, Integer>();
    while (sc.hasNextLine()) {
      st.put(sc.nextLine(), 0);
    }
    for( String s : st.keys()) {
      System.out.println(s);
    }
  }
}
```

사실 추상적인 맵 그자체의 개념에선 자동으로 정렬되느냐는 필수가 아니다. 다만 해당 클래스에서 사용된 맵의 이름은 BST라는 것인데,
**이는 우리가 추후 실제로 구현할 이진 탐색 트리를 의미한다.** BST는 항상 키를 정렬된 상태로 유지하며, 데이터 삽입 시 자동으로 정렬을 지원한다.

즉 해당 코드는 특수한 맵을 이용해 별도의 정렬 메서드를 구현하지 않고 문자열을 오름차순으로 출력 가능하게끔 하는 것이다.
(여담으로 난잡한 순서의 데이터가 입력될 시 순서를 보장해주지 않는 맵의 종류엔 실제 자바에선 HashMap() 이란 컬렉션이 존재한다.)


### 단어 카운팅

다음은 어떠한 문장에서 공통된 단어가 얼마나 반복되는지 각 단어마다 카운팅을 할 수 있는 예제이다.

``` java
public class Freq {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    BST<String, Integer> st = new BST<String, Integer>();
    while(sc.hasNextLine()) {
      String key = sc.nextLine();
      if(st.contains(key) st.put(key, st.get(key) +1);
      else st.put(key, 1);
    }
    for (String s : st.keys()) {
      System.out.printf("%8d %s\n", st.get(s), s);
    }
  }
}
```

해당 클래스는 마찬가지로 맵을 이용하여 특정 검색어가 이미 맵의 키로 존재한다면 실제 밸류에 +1을 하는 방식으로 카운팅을 한다.
순회 없이 빠르게 값을 변경 가능하다.


### 인덱스

마지막으로 특정 단어의 인덱스를 구해주는 코드이다. 상단의 코드들보다 약간 복잡할 수는 있어도 실용적이고 유용한 예제라고 생각한다.

```java
public class Index {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    BST<String, Queue<Integer> st = new BST<String, Queue<Intger>>();
    for (int i = 0; sc.hasNextLine(); i++) {
      String key = sc.nextLine();
      if(!st.contains(key)) st.put(key, new Queue<Integer>());
      st.get(key).enqueue(i);
    }
    for (String s : st.keys()) {
      System.out.println(s + " " + st.get(s));
    }
  }
}
```

해당 코드는 입력된 문자열들에 따라 새로운 큐를 밸류로 가지게 된다.
그리고 중복된 문자열이 등장할 때마다, 해당 키의 큐에다가 i의 값을 계속 추가할 것이다.
만약 입력받은 값이 {it , was, it, was, best} 라고 치면 it의 인덱스는 0과 2로 출력이 될 것이다.

이러한 인덱싱 코드는 생각보다 간결함에 비해 매우 다양하게 사용된다.

예를 들어 신용카드 계좌 번호, 웹 검색, 클라우드 스토리지 등의 시스템에서도 사용된다.
라우터와 인터넷 또한 데이터를 어딘가로 라우팅할 때 위치를 알아내어 테이블에서 값을 찾는 방식을 사용한다.


이처럼 컴퓨터 시스템에서 데이터를 효율적으로 관리하기 위해서는 맵을 잘 구현하는 것이 매우 중요하다는 사실을 알 수 있다. 맵은 상당히 강력하고 유효하다.
