# 맵

우선 우리는 선형적인 자료구조에서 유용하게 쓸 수 있는 이진 탐색과 병합 정렬이라는 유용한 알고리즘을 알게되었다. 
이를 통해 우리가 실제 서비스를 만든다고 할 때, 더욱 더 빠른 검색이 가능할 것이다. 다만 **기존의 데이터에 한해서**


즉 새로운 데이터가 추가될 때, 혹은 기존의 데이터를 갱신하는 경우 **전체 목록을 다시 정렬하고 갱신하는 것이 필요하게된다.**
이건 간단히 생각해봐도 매우 불편하고 시간이 오래 걸린다. 만약 데이터의 추가 삭제가 빈번한 서비스에선 큰 비용이 들 수 밖에 없을 것이다.

따라서 이 문제를 해결하기 위해선 더욱 유연한 새로운 자료구조가 필요하다. 우리가 곧 알게 될 **맵**(**Map**)이라는 자료구조가 바로 이러하다. 

## 맵이란 무엇인가?

먼저 우리가 겪는 문제를 좀 더 구체적으로 다루어보자. 다시 말하지만, 우린 이미 정렬된 리스트 혹은 배열에 관해서는 상당한 유연성을 가지고 있다.
문제는 **추가, 수정, 삭제**이다. 이는 마치 종이로 인쇄된 전화번호부가 겪는 문제와 비슷한데 예를 들어, 전화번호부에서 이름에 맞는 번호를 변경하고 싶다면 기존 전화번호부에는 그런 기능이 없어서 다음 해에 새로운 전화번호부가 인쇄될 때까지 기다려야만한다...

물론 우리는 현대의 디지털 시스템에 자리잡고 있고 코딩은 실제 메모리가 뒷받침되는 한 공간은 추가확장할 수 있기 때문에 기존의 종이 전화번호부처럼 '불가능'의 영역까진 아니다.
하지만 계속 반복해서 말하듯이, 우리는 **구현 그 자체에 만족을 해선 안된다는 것이다.**

이를 성능적으로도 만족할만한 자료구조가 바로 맵이다. 맵은 키-값 쌍을 저장하고 검색하는 ADT이다. 사실 개념 자체는 매우 심플하다.
위에서 언급한 전화번호부를 떠오르면 이해가 쉬운데, 전화번호부 좌측의 임의의 이름이 존재하고, 우측에는 그 사람의 전화번호가 존재한다.
여기서 이름이 키가 되는 것이고 값(밸류)은 전화번호가 되는 것이다.

결국 이 단순한 특성을 정적인 종이 전화번호부가 아닌 확장가능한 디지털 시스템에 적용시킨 것에 불과하다.

맵은 키를 통해 값에 접근하는 방법을 제공하고, 스택과 큐에서 그랬듯이 둘 다 어떠한 데이터 타입이든 가능해야한다.

우리가 기존에 알고있던 배열을 생각해보면 배열은 고정된 인덱스를 통해 접근이 가능했다. 맵은 그 키가 인덱스 역할을 대신한다고 보면 된다.
또한 배열은 한정된 크기를 가진 반면, 맵은 이론상 그 크기가 무한하다. 

**즉 임의의 데이터 접근에 리스트보다 훨씬 빠른 속도를 가지면서도 연결리스트처럼 확장 가능하다는 것이다.**

## 더 자세히

맵 자체는 추상 자료 구조이기 때문에 사용 언어에 따라 구현이 다를 것이다. 가장 간단하게 코드로 구현해보자면 이렇게도 쓸 수 있다.

``` python
phonebook["Alice"] = "123-456-7890"
```

비록 나는 파이썬을 아직 공부하지 않았지만, 이 코드를 이해하는데 문제가 전혀 지장이 없을 정도다. 키 값을 엘리스로 지정하고 앨리스의 밸류를 전화번호로 가지게끔 하는 방식이다.
물론 **자바에서는 이런 간단한 구현은 어림도 없는 일이다...** 과연 어찌 구현해야할까?

구체적 구현의 방향성을 정해보도록 하자.

**1. 기본적으로 모든 키는 고유하다.**

즉, 같은 키를 여러 번 사용할 수 없으며, 동일한 키를 추가하려고 하면 기존의 값이 갱신되는 식으로 작동하게 된다. 다만 이러한 가정이 항상 엄격하게 적용될 필요는 없다.

이는 우리가 응용 프로그램에서 다룰 때 필요에 따라 다르게 구현할 수 있는데 예를 들어 수강생이 듣는 과목이라는 걸 생각해보자.

특정 학생이 듣는 과목이 3개라고 가정했을 때, 특정 학생을 키값으로 잡는 맵을 구현할때 기존의 키 고유성을 그대로 지키면 어떻게 될까?
계속 과목이 갱신만 되는 어처구니없는 상황이 발생할 것이다. 따라서 우리는 좀 더 유연하게 생각해야한다.

**2.기본 연산**

매우 당연한 말이지만, 맵의 기본 연산은 주어진 키와 값을 연결하는 것에 의의가 있다. 이를 두 가지 경우로 나눌 수가 있는데 다음과 같다.
- 키가 맵에 없는 경우 새로운 키-값 쌍을 맵에 추가하면 된다.
- 이미 존재하는 키를 입력받은 경우 기존의 키와 연결된 값을 갱신하면 된다.

**3. 값을 반환도 해야한다.**

또 다른 기본적인 작업은 주어진 키를 지정했을 때 값을 반환하는것이다. 
임의의 키가 맵에 존재하는지 확인하고 있다면 그에 해당하는 값을 반환해야만 한다. 만약 해당 키가 없다면 null을 반환하거나 임의의 값을 반환하도록 구현할 수도 있다.

**4. 추가적으로 키에 대한 비교도 필요할 수 있다.**

가끔은 키들을 순서대로 정렬할 수 있는 기능을 상정해야하기도 한다. 예를들어, 키들이 정수, 문자열, 날짜 등의 형태라면 이를 크기 순서대로 비교하고 정렬이 가능할 것이다.
이러한 정렬을 지원하는 경우, 맵을 통해 데이터를 정렬된 순서로 순회하거나 특정 조건에 맞는 데이터를 빠르게 찾을 수 있게 된다.

**5. 유연한 크기와 제네릭 사용**

구현 시, 스택과 큐에서 언급한 제네릭을 사용해서 다양한 데이터 타입에서도 작동이 가능한 맵을 구현해야할 것이다.
또한 우리는 키 - 값으로 이루어진 쌍이 계속 추가될 수 있게 용량에 한계를 두어서는 안된다.


해당 개념들을 이용해 실제 API를 구현한다면 이렇게 짜볼 수 있을 것이다.

``` java
public class ST<Key extends Comparable<Key>, Value> //  키에 대한 비교를 가능케함 compartTo() 메서드 구현 필요.
St<Key, Value>() // 생성자
void put(Key key, Value val) // 추가 put 메서드
Value get(Key key) // 가져오기 get 메서드
boolean contains(Key key) // 포함여부 묻기
Iterable<Key> keys() // 맵의 모든 키에 접근
```

해당 강의에서는 나오지 않았지만 맵의 크기를 살펴보거나 특정 키를 삭제하는 메서드 역시 구현해야할 것이다.

또한 클래스에서 `public class ST<Key extends Comparable<Key>, Value>` 부분에 대해 설명을 해보겠다.

### public class ST<Key extends Comparable<Key>, Value>의 의미

기본적으로 맵을 구현할 때는 키(Key)에 대해 비교가 가능하게 하여 정렬하거나 특정 키를 찾는 연산을 수행할 수 있게 해야한다.

**Key extends Comparable<Key>**라는 표현은 **제네릭 타입의 키(Key)**가 Comparable 인터페이스를 구현해야 한다는 뜻이다.

이는 키로 사용되는 데이터 타입은 다른 키와 비교할 수 있어야 한다는 요구사항을 의미한다.
Comparable<Key> 인터페이스를 구현하면, 키들을 정렬하거나 특정 순서대로 처리할 수 있는 기능을 제공하게 된다. 이 기능은 맵에서 데이터를 관리하거나, 검색할 때 매우 중요하게 사용된다.

중요한것은 맵이란 것을 직접 구현할 때 키로 오는 타입은 **Comparable을 반드시 구현해야한다는 사실이다.**

예를 들어, ST<Integer, String> 이라는 맵을 만들 때 Integer 클래스는 이미 Comparable<Integer>를 구현하고 있기 때문에 별도의 구현 없이 사용이 가능하다.
(물론 해당 강의는 정말 어떠한 메서드나 타입도 구현이 안되어있고 직접 구현한다는걸 상정하기에 강의상의 세상에선 integer도 우리가 직접 구현하냐마냐를 따질것이다...)
그런데 만약 ST<Custom, String> 이라는 맵을 만든다면 해당 'Custom' 타입은 Comparable을 직접 구현해야한다는 것이다.


이것 외에는 대부분이 직관적으로 이해가 될 것이다. 문제의 메서드는 `Iterable<Key> keys()` 이다. 다른걸 떠나서 대체 `Iterable`이 무엇일까..?
본격적인 구현에 앞서 이 개념을 알고 가자.


### 이터레이션

**이터레이션**은 프로그래밍에서 **컬렉션 또는 여러 개의 데이터 요소들**을 반복적으로 하나씩 접근하여 작업을 수행하는 과정을 의미한다. 
쉽게 말해, 이터레이션은 목록이나 자료구조에 있는 모든 요소들을 순서대로 처리하는 작업이라고 볼 수 있다.

여기서 컬렉션은 사실상 자료구조라고 생각해봐도 무방하다. 
이터레이션은 이러한 컬렉션의 요소들을 하나씩 차례대로 접근하여 읽거나, 변경하거나, 특정 작업을 수행하는 것 그 자체를 말하는 것이다. 
사실 우리는 웬만해서 한 번 쯤은 이터레이션 작업을 해봤다고 할 정도로 익숙한 개념이다.

당장 반복문을 이용해서 특정 배열의 모든 요소들을 출력하는 코드를 생각해보자. 이게 이터레이션 작업 중 하나인 것이다.

자바에서는 컬렉션의 요소들을 반복적으로 처리할 수 있는 다양한 방법을 제공한다.

1. for-each 구문

for-each 구문은 컬렉션에 있는 모든 요소에 접근하기 위해 자주 사용하는 방법이다.
이 방식은 자바에서 간단한 이터레이션을 제공하여, 컬렉션의 내부적인 구현을 신경 쓰지 않고도 모든 요소를 쉽게 접근 가능하다.

예제 코드

``` java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
for (String name : names) {
    System.out.println(name); 
}
```

2. Iterator 인터페이스

자바에서는 이터레이션을 보다 유연하게 처리하기 위해 Iterator 인터페이스를 제공한다.
**Iterator**를 사용하면 컬렉션의 요소를 직접 접근하거나, 특정 요소를 삭제하는 등의 작업을 보다 세밀하게 수행할 수 있다.

예제 코드

```java
List<String> fruits = new ArrayList<>();
fruits.add("Apple");
fruits.add("Banana");
fruits.add("Cherry");

Iterator<String> iterator = fruits.iterator();
while (iterator.hasNext()) {
    String fruit = iterator.next();
    System.out.println(fruit);
}
```

3. Iterable 인터페이스

자바의 Iterable 인터페이스는 컬렉션이 반복 가능한 객체임을 나타내기 위해 사용된다.
이 인터페이스를 구현하는 클래스는 상단에서 언급한 for-each 구문을 통해 반복이 가능하게 된다.
모든 컬렉션 클래스(List, Set, Queue 등)는 기본적으로 Iterable 인터페이스를 구현하고 있어, for-each 구문으로 이터레이션이 가능하다.


즉 Iterable<Key> keys() 메서드는 사용자에게 맵의 모든 키를 쉽게 반복적으로 접근할 수 있도록 도와주는 기능을 제공하는 것이다.

이 메서드를 사용하면 모든 키에 대해 순회할 수 있기 때문에, 맵에서 모든 키를 하나씩 꺼내 작업을 수행해야 할 때 유용하다.

다음과 같은 예제를 보면 바로 이해가 될 것이다.

```java
ST<String, Integer> symbolTable = new ST<>();
symbolTable.put("Alice", 1);
symbolTable.put("Bob", 2);
symbolTable.put("Charlie", 3);

for (String key : symbolTable.keys()) {
    System.out.println("Key: " + key + ", Value: " + symbolTable.get(key));
}
```

이 코드는 해당 메서드를 호출하여 반환된 Iterable 객체를 통해 맵의 모든 키를 순회하고 각 키를 꺼내면서 그에 해당하는 값을 get() 메서드를 사용하여 출력한다.

해당 메서드의 본질은 실제 사용자가 키를 정수형 타입이든 문자열 타입이든 비교 가능한 요소로 지정하는 경우가 있을터인데, 이는 곧 **키에 대한 정렬과 빠른 탐색**이 요구되는 작업 역시 불가피하다는 것이다.
모든 키에 대한 접근은 우리가 기존에 배운 정렬과 탐색 알고리즘을 가능케 해준다.


## 어떻게 사용을 할까?

- 주의점
  - 해당 예제 코드에서 나오는 입력 로직은 실제로는 이미 존재하는 유한한 데이터들이 해당 메서드에 입력된다는 전제하에 구축된다.
  - 실제로 이 예제를 사용한다면 해당 클래스에 나오는 스캐너 코드는 어느정도 다른 입력을 상정하여 수정을 거쳐야 할 것이다.

### 문자열 정렬

간단한 클라이언트 예제로는 문자열을 정렬하여 출력하는 기능 생각할 수도 있다. 다음은 예제 코드다.

```java
public class Sort {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    // Sort lines on StdIn
    BST<String, Integer> st = new BST<String, Integer>();
    while (sc.hasNextLine()) {
      st.put(sc.nextLine(), 0);
    }
    for( String s : st.keys()) {
      System.out.println(s);
    }
  }
}
```

사실 추상적인 맵 그자체의 개념에선 자동으로 정렬되느냐는 필수가 아니다. 다만 해당 클래스에서 사용된 맵의 이름은 BST라는 것인데,
**이는 우리가 추후 실제로 구현할 이진 탐색 트리를 의미한다.** BST는 항상 키를 정렬된 상태로 유지하며, 데이터 삽입 시 자동으로 정렬을 지원한다.

즉 해당 코드는 특수한 맵을 이용해 별도의 정렬 메서드를 구현하지 않고 문자열을 오름차순으로 출력 가능하게끔 하는 것이다.
(여담으로 난잡한 순서의 데이터가 입력될 시 순서를 보장해주지 않는 맵의 종류엔 실제 자바에선 HashMap() 이란 컬렉션이 존재한다.)


### 단어 카운팅

다음은 어떠한 문장에서 공통된 단어가 얼마나 반복되는지 각 단어마다 카운팅을 할 수 있는 예제이다.

``` java
public class Freq {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    BST<String, Integer> st = new BST<String, Integer>();
    while(sc.hasNextLine()) {
      String key = sc.nextLine();
      if(st.contains(key) st.put(key, st.get(key) +1);
      else st.put(key, 1);
    }
    for (String s : st.keys()) {
      System.out.printf("%8d %s\n", st.get(s), s);
    }
  }
}
```

해당 클래스는 마찬가지로 맵을 이용하여 특정 검색어가 이미 맵의 키로 존재한다면 실제 밸류에 +1을 하는 방식으로 카운팅을 한다.
순회 없이 빠르게 값을 변경 가능하다.


### 인덱스

마지막으로 특정 단어의 인덱스를 구해주는 코드이다. 상단의 코드들보다 약간 복잡할 수는 있어도 실용적이고 유용한 예제라고 생각한다.

```java
public class Index {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    BST<String, Queue<Integer> st = new BST<String, Queue<Intger>>();
    for (int i = 0; sc.hasNextLine(); i++) {
      String key = sc.nextLine();
      if(!st.contains(key)) st.put(key, new Queue<Integer>());
      st.get(key).enqueue(i);
    }
    for (String s : st.keys()) {
      System.out.println(s + " " + st.get(s));
    }
  }
}
```

해당 코드는 입력된 문자열들에 따라 새로운 큐를 밸류로 가지게 된다.
그리고 중복된 문자열이 등장할 때마다, 해당 키의 큐에다가 i의 값을 계속 추가할 것이다.
만약 입력받은 값이 {it , was, it, was, best} 라고 치면 it의 인덱스는 0과 2로 출력이 될 것이다.

이러한 인덱싱 코드는 생각보다 간결함에 비해 매우 다양하게 사용된다.

예를 들어 신용카드 계좌 번호, 웹 검색, 클라우드 스토리지 등의 시스템에서도 사용된다.
라우터와 인터넷 또한 데이터를 어딘가로 라우팅할 때 위치를 알아내어 테이블에서 값을 찾는 방식을 사용한다.


이처럼 컴퓨터 시스템에서 데이터를 효율적으로 관리하기 위해서는 맵을 잘 구현하는 것이 매우 중요하다는 사실을 알 수 있다. 맵은 상당히 강력하고 유효하다.

## API 구현

결국엔 상단의 유용한 코드들을 실현시키기 위해선 효율적인 맵의 구현이 절실하다.

Zipf의 법칙이라는 것이 있다. 이 이론은, 가장 자주 쓰이는 단어가 그 글에서 t번 정도 나오면, 두 번째로 자주 나오는 단어는 t/2 정도로 나온다는 것이고, 세 번째 단어는 t/3 정도로 나온다는 것이다.

이러한 법칙이 유효한지는 우리가 만든 단어 카운팅 클래스로 쉽게 구할 수 있다. 문제는 입력이 어마무시하게 커지는 경우다.

`모비딕`이라는 책에선 약 100만 단어가 존재하는데 이는 그나마 약과이고, 코퍼스라는 언어 연구를 위한 언어 테스트의 모음집 같은 것에는 수천만개의 단어가 있을 것이다. 그리고 이를 우리가 실사용하는 웹상의 큰 텍스트 세트들을 본다면 그 숫자는 수십억에 다다를 것이다.

**좋은 맵**의 구현이 절실하다.


### 배열 구현은 어떠한가?

먼저 우리는 **자동 정렬이 보장되는 맵을 구현한다는 사실을 전제로 한다**

키에 대한 배열과 값에 대한 배열 두 개를 이용하여 맵을 구현한다면 어떨까?(실제로 이 강의를 듣기전 내가 막연히 생각한 방법이다...)

먼저 put의 경우, 특정 키와 값이 인덱스를 통해 서로 매칭시키면 그만이라 그럴싸하다. 또한 배열을 이용하면 병합 정렬과 같은 효율적인 정렬 알고리즘과 이진 탐색과 같은 탐색 역시 가능하다.

하지만 이러한 장점 뒤에는 치명적인 결함이 존재한다. 첫번쨰로는 스택과 큐의 구현에서도 겪었던 크기 문제이다. 

배열의 크기는 고정되어 있으므로, 더 많은 데이터를 저장해야 할 경우 새 배열을 만들어야 하는 불편함이 있다.

더욱 더 크나큰 문제는 새로운 키-밸류의 삽입시 발생한다. 새로운 키가 추가될 때마다 이미 있는 키들과 비교하여 정렬된 상태를 유지해야 하므로, 키들이 많아질수록 더 많은 요소를 이동해야한다.

이 때문에 삽입 작업의 시간 복잡도가 무려 **O(n^2)** 수준이 될 수 있다. 써먹을 수가 없다..


### 연결 리스트?

스택과 큐의 구현에서 했던 것처럼 연결 리스트를 이용하여 구현하면 어떨까?

노드 클래스를 구현할 때 키 필드와 밸류 필드 두 가지를 구축하여 키를 순서대로 연결하면 되지 않을까?

여기에도 치명적인 결함이 숨어있다. 바로 검색의 경우이다. 우린 이진 탐색이라는 강력한 탐색 알고리즘을 사용하고 싶다. 배열에선 이러한 작업이 매우 쉬웠다. 근데 연결 리스트에서는? **답이 없다.**

기존의 우리가 구현 가능했던 연결 리스트 방식에서는 순차적으로 검색하여 가운데로 이동하는 방법 뿐일 것이다.

우리는 좀 더 다른 접근을 해야한다.


### 이진 탐색 트리(Binary Search Trees)

우리는 연결 리스트에서 사용했던 노드의 링크 개념만 가져와 새로운 구현을 해볼 것이다.
사실 이런 링크를 이용하면 수많은 자료구조를 만들 수 있지만 당장 여기선 다루진 않겠다.

이진 검색 트리는 비교가능한 키와 두 개의 링크를 사용하는 **이중 연결 자료 구조**이다. 이는 곧 각 노드가 두 개의 참조를 가진다는 의미이다.

이진 탐색 트리는 재귀적인 자료 구조라서, 서로 비교 가능한 키들을 특정 순서에 따라 정렬하게된다. 이로 인해 데이터들이 이진 트리 형태로 정렬되게 된다.

또한 트리가 아예 비어있다면 NULL이고, 노드는 탐색 트리의 루트를 참조하게 된다. 좀 더 이를 구조화 시켜보자면 다음과 같다.

- 이진 탐색 트리의 구조
  - 키
  - 밸류
  - 왼쪽 하위 트리
  - 오른쪽 하위 트리

이는 약간 연결리스트를 확장한 것 같은 느낌을 가져다준다.

이를 좀 더 코드로 구체화 시켜보자.

```java
private class Node {
    private Key key;
    private Value value;
    private Node left;
    private Node right;
    public Node(Key key, Value value) {
        this.key = key;
        this.value = value;
    }
}
```

요컨데 하나의 노드는 키와 값을 가지고 하위 자식 노드로 좌/우 노드를 가지는 식이다. 여기서 이진 탐색 트리의 주요한 특징을 말할 수 있는데, **이진 탐색 트리의 하위 노드들은 해당 노드의 키보다 크냐 작냐로 순서가 지정된다는 것이다.**

예를 들어 루트 노드의 키가 1 이라는 숫자라고 치자. 그 후 키가 5인 새로운 노드가 BST에 추가되려고 한다.

그렇다면 이 노드는 해당 루트 노드의 right 노드로 가게된다. 즉 큰 자식 노드로 가게 된다.

이 후에 키가 2인 노드가 추가되면 어떻게 될까? 먼저 루트로 이동을 하고 오른쪽 자식 노드인 5보다는 작으므로 루트의 왼쪽 노드에 추가 될 것이다.

만약 7이 오면? 루트에서 2/5 둘 중 하나를 택해야하는데 7은 2와 5보다 더욱 크니까 5를 가지는 노드의 오른쪽 자식 노드로 가게 되는 것이다.

이러한 동작 원리를 제대로 구현하려면 어찌 해야할까? 바로 재귀적 구현을 해야만한다.

```java
// get 메서드
public Value get(Key key) {
    return get(root, key);
}
private Value get(Node x, Key key) {
    if (x == null) return null;
    int cmp = key.compareTo(x.key);
    if (cmp < 0) return get(x.left, key);
    else if(cmp > 0) return get(x.right, key);
    else return x.value;
}

// put 메서드

public void put(Key, Value val) {
    root = put(root, key, val);
}
private Node put(Node x, Key key, Value val) {
    if (x == null) return new Node(Key, val); // 루트 노드를 지정해야할 때
    int cmp = key.compareTo(x.key);
    if (cmp < 0 ) x.left = put(x.left, key, val);
    else if (cmp > 0) x.right = put(x.right, key, val);
    else     x.val = val;
    return x;
}
```

get 메서드도 그렇고 put 메서드도 그렇고 키끼리의 크기 비교를 이용하여 노드들을 연결한다. 매우 유용하다. 이진 탐색 트리나 병합 정렬에서도 보았던 재귀적 메서드 사용이라 나름 친숙함도 느껴진다.

다음은 Iterable의 구현이다.

``` java
public Iterable<Key> keys() {
    Queue<Key> queue = new Queue<Key>();
    inorder(root, queue);
    return queue;
}
private void inorder(Node x, Queue<Key> queue) {
    if( x == null) return;
    inorder(x.left, queue);
    queue.enqueue(x.key);
    inorder(x.right, queue);
}
```

이 역시 재귀적 메서드 사용을 잘 보여주는 예제이다. 이 메서드를 이용하면 모든 키를 잘 보여줄 수 있다.


### 구현 사양과 전체 코드

결국 성능의 구현 사양이 중요하다. 우리의 이진 탐색 트리 api는 다음과 같은 조건을 충족해야한다.

- 추가와 검색에는 평균적으로 O(log n) 의 시간복잡도를 가져야되고
- 실제 메모리 사용량은 해당 맵의 크기와 비슷해야한다.
- 가장 중요한건 크기에 제한이 없어야한다.

``` java
public class BST<Key extends Camparable<Key>, Value> {
    private Node root = null;

    private class Node {
        private Key key;
        private Value value;
        private Node left;
        private Node right;
        public Node(Key key, Value value) {
            this.key = key;
            this.value = value;
        }
    }
    public boolean isEmpty() {
        return root == null;
    }
    public boolean contains(Key key) {
        return get(key) != null;
    }
    public Iterable<Key> keys() {
        Queue<Key> queue = new Queue<Key>();
        inorder(root, queue);
        return queue;
    }
    private void inorder(Node x, Queue<Key> queue) {
        if( x == null) return;
        inorder(x.left, queue);
        queue.enqueue(x.key);
        inorder(x.right, queue);
    }
    public Value get(Key key) {
    return get(root, key);
    }
    private Value get(Node x, Key key) {
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp < 0) return get(x.left, key);
        else if(cmp > 0) return get(x.right, key);
        else return x.value;
    }

    // put 메서드
    
    public void put(Key, Value val) {
        root = put(root, key, val);
    }
    private Node put(Node x, Key key, Value val) {
        if (x == null) return new Node(Key, val); // 루트 노드를 지정해야할 때
        int cmp = key.compareTo(x.key);
        if (cmp < 0 ) x.left = put(x.left, key, val);
        else if (cmp > 0) x.right = put(x.right, key, val);
        else     x.val = val;
        return x;
    }
}
```

## 향후 방향성

우리는 이진 탐색 트리를 이용한 맵을 구현해보았고, 이를 이용한 클라이언트 코드도 구현했다.
허나 우리가 알아야할 것은 좀 더 본질적인 문제이다.

이진 탐색 트리는 난잡한 순서를 가진 데이터들이 삽입될 경우 트리의 균형이 유지될 가능성이 높다. 이는 곧 성능에 직결되어 O(log n)**의 시간 복잡도를 유지하게 되는 원리가 된다.

문제는 **크기 순서대로 들어오는 데이터**이다. 이는 사실상 연결리스트를 쓰는 것과 다름이 없는 **편향 트리** 구조가 되어버린다.

실제 강의에서 255개의 무작위 키를 BST에 삽입하는 시물레이션을 진행했다고 하는데, 완벽한 균형을 이루지는 못했지만 어느정도 균형 잡힌 상태를 유지했다.

구체적인 수치로는 무작위 순서로 키를 삽입할 때의 비용은 기존 성능 1.39~2를 곱한 정도이며, 이는 완벽한 균형 트리와 비교했을 때 약 40% 의 추가 비용이 들었지만 이럼에도 상당히 효율적이라고 볼 수 있다.

그럼에도 우리는 더욱 더 나은 성능을 위해 균형 유지를 위한 노력은 불가피해보인다.

이러한 균형 유지 문제를 해결하기 위해 개발된 자료구조가 있다. 바로 AVL 트리와 레드-블랙 트리이다.(여담으로 후자의 자료구조는 실제 강의 교수가 자신의 팀과 함께 실제로 구현한 자료구조라고 한다...)

해당 자료구조들에 대해선 나중에 다룰 수는 있겠지만 여기선 직접 다루지는 않겠다. 다만 후자의 레드-블랙 트리의 경우엔 자바의**TreeMap**으로서 사용이 가능하다.

또한 이 역시 나중에 다루겠지만 **해싱**이라는 또 다른 방법을 이용하여 순서가 중요하지 않은 응용 프로그램에 활용할 수 있다. 해싱은 트리와 다른 특성과 효율성을 가지고 있다.

우리는 결론적으로 상당히 유용한 자료구조를 구축할 수 있는 능력을 얻게 되었다.

강의의 말을 빌려 쓰자면 **1조 명의 고객을 확보한다면 그 중에서 80개 미만의 비교를 통해 그 고객들 중에서 검색할 수 있을 것이다. 또한 우주에 모든 원자가 있다고 해도 200개만 비교하면 된다는 것을 보장할 수 있다**
