# 개요

우리가 사용하는 실제 문자 언어를 생각해보자. 문자 언어는 기호를 나열한 것이다. 언어마다 기호 자체가 달라질 수도 있고, 읽는 순서 역시 달라질 수 있으며, 기호의 순서에 따라 의미가 달라지기도 한다.
모든 언어의 뜻은 이러한 체계를 바탕으로 만들어진 기호의 집합으로 **인코딩**된다. 하지만 이것만으로는 충분하지 않다. 더욱 중요한 것은 바로 **문맥**인데 모두가 같은 문맥을 공유하여 **같은 기호에 같은 뜻을 부여할 수 있어야 한다.**
**현실 세계에서도 그렇듯, 언제나 문맥을 명확히 식별할 수 있는 것은 아니다. 이는 컴퓨터 언어에도 마찬가지인 문제이다.**
여기서 말하는 '컴퓨터 언어'는 단순히 프로그래밍 언어만을 의미하지 않는다. 컴퓨터 언어란 **컴퓨터 내부의 전반적인 체계를 이해하기 위한 최소 단위의 표현 방식**이라 생각하면 된다. 이는 **이진법을 바탕으로 한** 데이터 표현, 논리 연산, 명령어 집합 등을 포함하는 개념이다.

## 비트

문자 언어의 틀을 이루는 세 가지 구성요소에 대해 적자면 다음과 같다.

  - 기호가 들어갈 상자
  - 상자에 들어갈 기호
  - 상자의 순서

이러한 구성요소는 컴퓨터 언어에서도 마찬가지라고 볼 수 있다. 먼저 상자에 대해 생각해보면, 자연어(현실 세계에서 사용되는 언어)에선 **문자**라고 부르는 것을 컴퓨터에선 **비트**라고 부른다. 

**비트**는 2진법을 사용한다는 뜻의 바이너리(binary)와 숫자를 뜻하는 디지트(digit)가 합쳐진 말이다.(여담으로 디지트라는 말은 10진수를 표현 10가지 기호를 뜻하는 말이다.) 비트는 2진법을 사용하는데, 오직 두 가지 기호를 여러가지 방식으로 조합해 이어붙여서 복잡한 정보를 표현한다. 여기서 중요한건 **기호는 추상적인 개념**이라는 사실을 기억해야한다. 이는 숫자가 될 수 있고 참 거짓이 될 수도 있다.

## 논리 연산

비트의 사용법 중 하나는 예/아니오 질문에 대한 답을 참/거짓으로 표현하는 것이다. 하지만 **하나의 비트로 표현할 수 없는 상황**이 많이 발생한다. 이러한 경우 **여러 비트를 조합해 문제를 해결**해야 하는데, 이때 사용하는 것이 바로 **논리 연산**이다. 논리 연산은 여러 비트를 조합하여 새로운 값을 만들어내는 방식으로, 대표적인 연산으로는 **AND, OR, NOT** 등이 있다.

### 불리언 대수

불리언 대수는 1800년대 조지 불이 만들어 낸 연산규칙의 집합으로서, 비트에 대해 사용할 수 있는 대표적인 연산 중 하나이다. 결합 법칙, 교환 법칙, 분배 법칙을 그대로 적용 가능하다.
기본적으로 불리언 연산자는 **AND, NOT, OR** 세 가지고, 합성 연산으로서 **XOR** 이 존재한다.

- **AND**
  - 둘 이상의 비트에 작용하는 연산으로서, 2비트 연산인 경우, 두 가지 비트가 모두 참일 경우에 결과가 참이 된다. 즉 **각 비트가 모두 참일 때** 연산의 결과가 참이 된다.
- **NOT**
    - 논리적 반대를 의미하며 하나의 비트에도 작용 가능하다. 예를 들어 어떠한 비트 하나가 참인 경우에 NOT 연산을 하면 거짓이 된다.
- **OR**
    - 이 연산도 둘 이상의 비트에 작용하는 연산으로, **각 비트 중 하나라도 참이라면** 연산의 결과도 참이 된다.
- **XOR**
    - 배타적(Exclusive) OR 이라는 뜻으로 첫번째 비트와 두번째 비트가 **서로 다를 때만 참이 된다.**
 
#### 드모르간의 법칙 

드모르간의 법칙은 두 개의 논리 연산식을 변환하는 데 사용되는 규칙으로, **NOT, AND, OR 연산 간의 관계를 재정립할 수 있다.** 이 법칙을 이용하면 특정 논리식을 더욱 간단하게 표현하거나, 특정 상황에서 논리 연산을 쉽게 이해할 수 있다. 

드모르간의 법칙은 다음과 같은 두 가지 주요 형태로 표현된다:

**1. NOT (A AND B) = (NOT A) OR (NOT B)** 

**2. NOT (A OR B) = (NOT A) AND (NOT B)**

즉, AND 연산과 OR 연산을 반대로 바꾸면서 각 항에 NOT을 붙이는 방식이다. 이 말은 NOT을 충분히 사용하면 AND를 OR로, 혹은 역으로도 대신할 수 있다는 것이다.
컴퓨터에서 입력을 항상 원하는 형태로 얻을 수는 없기 때문에 이러한 성질은 매우 유용하다.
저 법칙을 응용하여 다음과 같은 예시를 적을 수도 있다. 왼쪽에는 **긍정적인 논리**(정논리), 오른쪽에는 **부정적인 논리**(부논리)를 적었다.

```
            A OR B                                       (NOT A AND NOT B)                                   NOT(NOT A AND NOT B)
----------------------------------          ---------------------------------------------                  ------------------------
춥다 | 비가 온다 | 코트를 입는다                  NOT 춥다  | NOT 비가 온다 | NOT 코트를 입는다                      코트를 입는다
F        F          F                           F            F                F                                       F
F        T          T                  =>       F            T                F                   NOT                 T
T        F          T                           T            F                F                   =>                  T
T        T          T                           T            T                T                                       T
```

즉 A OR B 는 NOT(NOT A AND NOT B)와 같다는 사실이 도출된다. 이러한 드모르간의 법칙 사용은 **연산을 최소로 사용하여 비용을 최소화할 수 있다.**
<br>

## 정수를 비트로 표현

십진수를 생각해보자. 십진수는 밑이 10인 수 체계다. 이는 곧 자릿수가 10의 거듭제곱 꼴로 나타내진다. 5018이라는 숫자가 있을 때 이를 다르게 표현해보면
```
5*10^3 + 0*10^2 + 1*10^1 + 8*10^0 = 5018
```
이렇게도 표현이 가능하다. 

비트를 사용할 때도 이와 비슷하게 표현이 가능하다. 밑이 2라는 점 때문에 **기호를 담을 상자, 자릿수**가 더 많이 필요하다는 차이점이 있을 뿐이다.
예를 들어 숫자 9를 생각해볼 때, 십진수에선 한 자릿수로만 해결이 가능하다. 이진수는 **0과 1**만 사용이 가능하고 밑을 2로 가지기 때문에 1보다 큰 수를 표현할 때 부터 자릿수가 늘어난다. 두번째 상자, 즉 두번째 자릿수에는 어떤 이름이 붙을까?
바로 **2의 자리**이다. 이런식으로 자릿수에 따라서 2를 거듭제곱하여 값의 자리를 표현한다. 즉 숫자 '9'를 이진수로 표현하면 다음과 같은 결과가 나온다.

```
1*2^3 + 0*2^2 + 0*2^1 + 1*2^0 = 9 이를 이진수로 표현하면 -> 1001라는 4비트 수가 된다.
```

비트는 기호를 담을 상자라고 말을 했고, 여기서는 이진수의 자릿수로 표현이 된다고 하였다. 이는 다시 말해서 **임의의 비트로 값의 개수와 값의 범위를 산출 가능하다는 것이다.** 
다음 예시는 여러 가지 비트 개수를 사용해 표현할 수 있는 수의 범위를 보여준다.

```
비트 개수 | 값의 개수 | 값의 범위
    4          16        0-15
    8          256       0-255
    12         4096      0-4095
    16         65536     0-65535
    등등... 
```

2진수에서 가장 오른쪽의 비트를 **가장 작은 유효 비트**(**least significant bit**) 라고 부르고, 가장 왼쪽의 비트를 **가장 큰 유효 비트**(**most significant bit**)라고 부른다.

  - **가장 작은 유효 비트**(LSB)
    - LSB는 이진수 표현에서 가장 오른쪽에 위치한 비트를 의미한다. LSB는 숫자 값에 가장 작은 영향을 미치는 비트로, 이 비트를 바꾸면 전체 값의 변화폭이 가장 작다.
    - 2진수의 특성상 LSB가 1이면 홀수, LSB가 0이면 짝수가 된다. 이 방식으로 홀/짝수 확인을 빠르게 할 수 있다.
   
  - **가장 큰 유효 비트**(MSB)
      - MSB는 숫자 값에 가장 큰 영향을 미치며, 이 비트를 바꾸면 값의 변화폭이 가장 크다.
      - 후술하겠지만, 부호 있는 정수에서 MSB는 부호를 결정하는 역할도 한다.
   
  - **공통 사항**
    - 데이터 전송 시 MSB First와 LSB First 방식으로 구분할 수 있다.
    - 예를 들어, 네트워크 전송 시 프로토콜에 따라 먼저 전송할 비트를 결정하는 데 MSB나 LSB가 중요한 역할을 한다.
    - **빅 엔디언**(Big-Endian) 방식은 MSB를 먼저 전송하고, **리틀 엔디언**(Little-Endian) 방식은 LSB를 먼저 전송한다.
    - 이러한 방식은 **CPU 아키텍처**에 따라 달라지며, 데이터 전송의 호환성 문제를 다룰 때 **엔디언**을 고려해야 한다.
   
또한 MSB에 리딩제로라고 불리는 0을 추가하면 어떤 값을 표현하는 데 필요한 최소한의 자릿수보다 더 많은 자릿수를 추가할 수 있다. 이는 컴퓨터가 **미리 정해진 수의 비트**를 한 덩어리로 사용하도록 만들어졌기 때문에, 2진수를 쓸 때는 이런식으로 항상 일정한 개수의 비트를 사용해 값을 표현하는 경우가 종종 있다.(예시 : 10 이라는 이진수를 0010으로 표현 가능)
   
### 2진수의 덧셈

2진수의 덧셈은 기존에 10진수로 계산하던 방식과 비슷하다. LSB에서 MSB 쪽으로 더하여 각 자릿수가 1보다 크다면 1을 다음 자리로 올린다.
**중요한건 컴퓨터 내부에서 이 덧셈을 어떻게 연산하느냐인 것이다**

이 파트에선 자세히 다루지 않겠지만, 2진 덧셈을 위에 언급한 **불리언 연산**으로도 표현 가능하다. 두 비트를 서로 더한 결과는 두 비트를 **XOR** 한 값과 같고, 올림은 두 비트를 **AND** 한 값과 같다.

덧셈 결과가 우리가 사용하기로 정한 비트의 개수를 벗어나는 범위의 수라면 어떻게 될까? 이럴 경우에 그 유명한 **오버플로우**(Overflow)가 발생한다. 이는 곧 MSB에서 올림이 발생했다는 뜻이다.
예를 들어, `1001`과 `1000`을 더한 결과는 2진수로 표현하면 `10001`이다. 그런데 비트의 개수가 4로 한정되는 경우엔 MSB쪽에 사용할 수 있는 비트가 없어 **`0001`** 이라는 결과가 나오게 된다.
  - 이 파트에선 다루진 않겠지만, **조건코드 레지스터** 라는 것이 있는데 이런 정보 중에선 **오버플로 비트**라는 것이 있다.
  - 이 비트에서는 MSB에서 발생한 올림값이 들어가, 이 비트값을 보면 오버플로우가 발생했는지 알 수 있다.
  - MSB 위쪽에서 1을 빌려오는 경우를 **언더플로** 라고 부른다.

### 음수 표현

뺄셈은 어떠한 수에 다른 수의 음수를 더하는 것과 같다. 즉 덧셈을 넘어 뺄셈을 표현하고자 하려면 음수 표현이 중요하다.

우리는 흔히 음수와 양수를 구분할 때 부호를 사용한다. **컴퓨터에선 MSB를 부호에 사용하기로 약속했다.** 즉 4비트를 사용할 때 MSB를 부호 기호로 사용하면 남는 경우의 수는 0-7까지 표현이 된다.
부호 비트가 **0이면 양수** **1이면 음수**라고 취급하기로 했다.

한 비트를 부호에 사용하고 나머지 비트를 수의 크기, 즉 0부터의 거리를 표현하기 위해 사용하는 방법을 **부호화 크기** 표현법이라고 한다. 다만 이러한 표현법은 아래와 같은 이유로 널리 쓰이지 못하고 있다.

1.비트를 구상하려면 비용이 드는데 **0을 표현하는 방법이 두가지로 생겨버린다.**

2.위에 잠깐 언급했던 XOR과 AND를 통한 덧셈을 사용할 수가 없다.
  - 예를 들어 1과 -1을 더하고 싶다고 칠 때 실제 결과값은 0이지만, 부호화 크기 표현법으로 이를 계산하면 **-2가 되어버린다**
```
0001 + 1001 = 1002
```

그럼 두가지 문제점을 해결하는 방법은 무엇일까? 바로 **2의 보수** 표현법을 사용하는 것이다.

예를 들어 4비트짜리 공간에 +1을 표현하여, 0001이라는 수를 써보자. 이 비트를 전부 뒤집은 1110이라는 수에(여기서 멈추면 1의 보수 표현법이다) +1을 더하는 것이다. 즉 **-1을 4비트 기준 1111로 표현하는 것이다**
이렇게 되면 0이라는 숫자는 4비트 기준, 0000이라는 하나의 수로만 표현되고, 기존의 덧셈을 그대로 사용할 수 있다. 여기서 중요한건 **사용하기로 정한 비트의 개수가 명확할 때 오버플로우를 이용하는 것이다.**

예를 들어 우리가 총 4비트를 이용한다고 하고, 0001과 1111을 더한다고 치자. 계산을 하면 실제로는 10000이라는 이진수 결과값이 나오지만 최대 MSB를 벗어나게 되어 우리가 실제로 얻어내는 값은 **0000**이 된다.
<br>

## 실수 표현

밑이 10인 실수에는 우리가 흔히 쓰는 10진 소수점이 포함된다. (0.457, 1.5, 900.08 등등...) 마찬가지로 밑이 2인 경우, 실수를 표기하기 위해 2진 소수점을 표현할 방법이 필요하다.

### 고정소수점 표현법
2진수를 사용해 소수를 표현하기 위해 2진 소수점의 위치를 임의로 정하는 방법이 있다. 예를 들어 4비트가 있다고 치면, 왼쪽 2비트는 정수를 표현하는데 쓰고 오른쪽 2비트는 분수들을 표현하는데 사용하는 것이다.
소수점의 위치가 항상 일정하기 때문에 이런 방식을 **고정소수점** 표현법이라고 부른다. 아래에는 간단한 예시를 적어놨다.

```
정수부분  |  분수부분  |    값
  0|0    .     0|1      1/4(0.25)
  0|1    .     1|0      1+1/2(1.5)
```

즉 분수 부분의 자릿수에 따라 **2의 거듭제곱을 분모로 사용하는 것이다** 이러한 접근 방식은 작동 자체에는 문제가 없다. 문제는 **쓸모있는 범위의 실수값을 표현하기 위해 필요한 비트 개수가 너무 많다.**
우리가 흔히 사용하는 컴퓨터에는 잘 사용하지 않는 방식이다.(다만 디지털 신호 처리 장치 등 특별한 목적에 쓰이는 일부 컴퓨터에는 사용하기도 함)

### 부동소수점 표현법

위에 있는 고정소수점을 이용하여 실수를 표현할 때, `플랑크 상수`부터 `아보가드로 수`에 이르는 범위의 값을 표현하려면 무려 **수백 비트**를 사용해야한다.
  - 플랑크 상수의 값은 6.63 * 10^-34 (J/s), 아보가드로 수는 6.02*10^23/몰이라는 수이며, 두 수의 범위는 2^191 정도 된다. 이를 표현하려면 거의 200비트가 필요하다...
이를 해결하기 위해 `과학적 표기법`을 2진수에 적용시킨다. 예를 들어서, 10진 소수점 왼쪽이 한 자리 뿐인 소수(가수라고 부른다)에 10의 거듭제곱한 값을 곱하는 방식으로 표기한다.

```
0.012 = 1.2 * 10^-2
```

이를 밑이 2인 2진수에도 적용이 가능해진다. 여기서 유의해야할 점은 **지수의 밑인 2라는 숫자는 비트로 표현할 필요는 없다는 것이다.** 정의상 밑 2는 항상 정해져 있다. 아래는 간단한 예시들이다.

```
가수  |  지수  |   값
0  . 0   0|0    0(0*2^0)
0  . 1   0|0    0.5(1/2 * 2^0)
0  . 1   0|1    1.0(1/2 * 2^1)
1  . 0   1|1    8.0(1 * 2^3)
```

이러한 표현법은 비효율성이 상당하다. 예시에는 안나왔지만, 4비트 기준으로 0을 표현하는 방법이 4가지나 될 뿐더러 다른 숫자도 두 가지 씩 있는 경우가 허다하다. 또한 비트 패턴이 가능한 모든 수를 표현 불가능하다. 
**예를 들어 6.5를 표현하는 비트 패턴이 마땅히 없기 때문에 6.0에 해당하는 수와 0.5에 해당하는 수가 있더라도 둘을 더할 수는 없다.** 이를 보완하고자 **IEEE 부동소수점 수 시스템** 이라는 표준 방법을 이용하고 있다.

### IEEE 부동소수점 수 표준

이 방법은 위에서 쓴 4비트 부동소수점 표현보다 훨씬 많은 비트를 사용하며, 가수와 지수에 대해 각각 부호 비트를 사용한다.(다만 지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져있다.)
IEEE 표준이 똑같은 비트를 사용하더라도 정밀도를 가능한 한 높이는 방법으로는 두 가지가 존재한다. 한 가지는 **정규화**이다

정규화는 가수를 조정해서 맨 앞에 0이 없게 만드는 것이다. 정확히는 **숫자에 1을 앞에 붙이는 것이 아니라 소수점 위치를 조정하여 가수를 `1.xxxx` 형태로 만드는 것**이다.

```
0.511을 이진수로 표현하면 약 0.100000101110000101... 이라는 수가 나오는데 이를 1.0000010111... × 2^-1 처럼 표현하는 것이다.

이런 식으로 가수를 조정하면 당연히 지수도 조정해야한다.
```
두 번째 방법은 어차피 가수의 맨 왼쪽 비트가 1이라는 사실을 우리는 모두 인지하고 있으므로, **이를 생략하여 가수에 1비트를 더 사용하는 것이다.**


우리는 이 표준 방법에서 두 가지 부동소수점 수가 자주 쓰인다는 사실을 알아둬야한다. 하나는 **기본정밀도 부동소수점 수**(단정도 실수)이고, 또 하나는 **2배 정밀도 부동소수점 수**(배정도 실수)이다.
기본 정밀도 수는 32비트를 사용하며 7비트 정밀도로 대략 `+-10^+-38` 정도의 범위를 표현 가능하고 2배 정밀도 수는 64비트를 사용하기 때문에 더 넓은 범위를 표현 가능하다. 2배 정밀도는 15비트 정밀도로 대략 `+-10^+-308` 범위의 수를 표현할 수 있다.


두 형태 모두 가수에 대한 부호를 사용한다. 배정도 실수가 단정도 실수에 비해 지수가 3비트 더 큰데, 이는 곧 지수의 범위가 8배 더 크다는 것이다. 또한 배정도 실수는 단정도 실수에 비해 가수가 29비트나 더 크다. 정밀도 역시 큰 차이를 보인다.
**다만 이 모든 장점은 비트를 2배 더 많이 사용함으로서 얻은 것이다.**

  - **이러한 두 가지 부동소수점 수를 실제로 확인 가능한 것이 있다. 바로 프로그래밍 언어에서 흔히 사용되는 float/double 자료형이다.**

