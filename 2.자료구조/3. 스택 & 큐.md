# 스택과 큐

스택과 큐라는 두 가지 기본적인 자료구조에 대해 이야기해 보겠다. 둘 다 상당히 기본적이면서도 실제로 다양한 프로그램에서 매우 중요한 역할을 한다.
이전 문서에서 간략히 언급했지만 더 자세히 기술하도록 하겠다.

우선 왜 이 둘을 따로 설명하지 않고 같이 묶어서 설명할까?

이 두 자료구조는 꽤나 유사한 점이 많기 때문이다. 스택과 큐는 추상 데이터 유형(Abstract Data Type)으로, 데이터의 집합과 그것을 다루는 연산을 명확하게 정의한 것이라 볼 수 있다. 이 두 구조 모두 데이터를 넣고 빼는 방식이 다를 뿐 그 메커니즘이 간단하다는 점에서 유사하다.

모든 데이터 유형은 특정한 값들의 집합을 가지고 있고, 그 값을 어떻게 다룰지 고민해야 한다. 여기서 중요한 설계 과제는 어떤 **자료구조를 사용해야 가장 효율적인가?** 라는 점이다.

이를 결정할 때 고려해야 할 두 가지 주요 요소가 있다.

첫 번째는 그 자료구조가 얼마나 많은 메모리를 사용하는지이다. 

두 번째는 그 데이터 구조를 사용할 때 각 연산이 얼마나 빠르게 수행될 수 있는지, 즉 시간적인 효율성이다. 이 두 가지 요소는 특히 많은 데이터를 다루는 프로그램을 설계할 때 중요한 기준이 되며, 어떤 자구조를 선택할지 결정하는 데 큰 도움이 된다.

## 스택

먼저 스택에 대해 살펴보자. 

스택은 데이터를 추가하고 제거하는 방식에서 "**마지막에 추가된 데이터가 가장 먼저 제거된다**"라는 LIFO(Last In, First Out) 원칙을 따른다. 

스택의 주요 연산으로는 `push`와 `pop`이 있다. `push`는 새 항목을 스택에 추가하는 작업이며, `pop`은 스택에서 가장 최근에 추가된 항목을 제거하고 그 값을 반환하는 작업이다. 이때 스택은 언제나 마지막에 들어온 항목이 가장 먼저 나간다. 예를 들어, 스택에 "A", "B", "C" 순으로 넣었다면, `pop`을 수행할 때 가장 최근에 추가된 "C"부터 제거된다. 이런 식으로 스택은 데이터를 쌓아두고, 쌓은 순서의 역순으로 꺼내는 구조이다.

좀 더 구체적으로 구현 방향성을 써보자. 그 전에 자바 예제에 나오는 제네릭(Generic)이라는 요소에 대해 설명 먼저 하겠다.

### 제네릭

제네릭(Generic)이라는 개념은 Java와 같은 프로그래밍 언어에서 코드의 재사용성을 높이고, 다양한 데이터 유형을 보다 효율적으로 다룰 수 있게 해주는 중요한 기능이다. 
좀 더 쉽게 설명하자면, 제네릭은 데이터 유형에 구애받지 않고 코드를 작성할 수 있게 해 주는 도구라고 볼 수 있다.

보통 우리가 프로그래밍할 때 특정 데이터 유형을 명확하게 정해줘야 한다. 예를 들어, int형 리스트를 만든다면, 그 리스트에는 오직 정수만 들어갈 수 있다. 그런데 만약 문자열이나 다른 유형의 데이터를 담고 싶은 경우에는 새로운 리스트를 만들어야 한다. 여기서 제네릭을 사용하면, 리스트가 어떤 데이터 유형이든 받을 수 있도록 할 수 있다. 즉, 같은 코드로 여러 유형의 데이터를 다룰 수 있게 되는 것이다.

#### 사용 예시 

ava에서는 <>를 사용해 제네릭을 선언한다. 예를 들어, ArrayList<T>와 같은 형태로 제네릭 타입을 지정하는데, 여기서 T는 "타입의 약자"로 일종의 자리 표시자 역할을 한다. 코드 작성 시에는 T 대신 정수형(Integer), 문자열(String) 같은 실제 데이터 유형을 넣어서 사용할 수 있다.

```java
// 정수형 리스트
ArrayList<Integer> intList = new ArrayList<>();

// 문자열 리스트
ArrayList<String> stringList = new ArrayList<>();
```

위 예시에서 보듯이, ArrayList<T>라는 제네릭 타입 덕분에 우리는 리스트를 정수형으로도, 문자열형으로도 만들 수 있다. 만약 제네릭이 없다면, 각각 ArrayListInt, ArrayListString 같은 다양한 리스트 클래스를 만들어야 했을 것이다. 제네릭을 사용함으로써 코드가 훨씬 더 간결하고 재사용 가능하게 된다.

### 스택의 구체적 구현 방향성

``` java
public class Stack<Item>

Stack<Item>(); : 모든 타입에 대한 데이터들로 구성될 수 있는 스택이 구현되어야 함
void push(Item item); : 데이터 추가
Item pop(); : 가장 최근에 push된 데이터를 제거하고 그 데이터를 리턴해야한다.
boolean isEmpty() : 말 그대로 스택에 비었는가를 판단
int size() : 현재 스택의 크기
```

스택이란 개념 자체는 매우 추상적이기에 실제 코드로 구현하기 위해서 이같은 지침이 우리에겐 필요하다.(실제로 부가적인 메서드 구현을 해도 스택의 본질만 해치지 않으면 무방하다.) 물론 저 메서드 중에서 제일 중요한건 후입후출의 원칙의 근간인 push와 pop의 구현이다.

## 큐

이제 큐에 대해 이야기해 보자. 

큐는 스택과 유사하지만, 데이터를 추가하고 제거하는 규칙이 조금 다르다. 

큐는 "먼저 들어온 데이터가 먼저 나간다"라는 FIFO(First In, First Out) 원칙을 따른다. 대기열을 생각하면 쉽다. 

큐의 주요 연산으로는 `enqueue`와 `dequeue`가 있다. `enqueue`는 큐의 끝에 새 항목을 추가하는 연산이며, `dequeue`는 큐의 앞부분에서 가장 오래된 항목을 제거하고 그 값을 반환하는 연산이다. 예를 들어, 큐에 "A", "B", "C" 순으로 넣었다면, `dequeue`를 수행할 때 가장 처음에 들어온 "A"부터 제거된다. 이렇게 큐는 데이터를 순서대로 처리하는 데 유용하다.

### 큐의 구체적 구현 방향성

``` java
public class Queue<Item>

Queue<Item>(); : 모든 타입에 대한 데이터들로 구성될 수 있는 큐 구현되어야 함
void enqueue(Item item); : 데이터 추가
Item dequeue(); : 가장 먼저 enqueue된 데이터를 제거 및 리
boolean isEmpty() : 말 그대로 스택에 비었는가를 판단
```

마찬가지로 큐란 개념 자체는 매우 추상적이기에 실제 코드로 구현하기 위해서 이같은 지침이 우리에겐 필요하다.(실제로 부가적인 메서드 구현을 해도 큐의 본질만 해치지 않으면 무방하다.) 물론 저 메서드 중에서 제일 중요한건 선입선출의 원칙의 근간인 enqueue와 dequeue의 구현이다.


## 더 자세히

값들이 모두 같은 유형으로 이루어진 항목들의 집합을 **컬렉션** 이라고 해보자. 예를 들어, 정수들만 모아놓은 리스트나 문자열들만 모아놓은 배열 같은 것이다.
또한 이런 식으로 값들이 모두 같은 유형의 항목들로 이루어진 컬렉션은 "멀티셋"이라고 부를 수 있다. 여기서 멀티셋이란, 중복된 값들을 포함할 수 있는 집합을 의미하는 것이다.

결국 이와 같은 개념을 가지고 여러 기본적인 자료구조가 만들어지는 것이다. 위에서 서술한 스택과 큐에 대해서 생각해보자.

이 두 자료구조는 데이터의 모임이라는 점에서 기본적으로 유사하지만, 데이터를 넣고 빼는 방식의 "작업 규칙"에서 차이가 있다. 즉, 스택은 마지막에 들어온 것을 먼저 빼는 반면, 큐는 먼저 들어온 것을 먼저 빼는 식으로, 데이터 처리 방식만 다르다. 이런 차이 때문에 작업 사양(작업을 처리하는 방법)에 있어 세부적인 차이가 있을 뿐, 기본적으로는 유사한 자구조라고 할 수 있는 것이다.

다른 중요한 점은 스택과 큐 모두 정의상, 미리 정해진 크기의 제한이 없다는 것이다. 이는 프로그램의 입장에서 보면 이는 메모리의 제약에 얽매이지 않고 유연하게 데이터를 관리할 수 있음을 의미한다. 컴퓨터가 점점 더 많은 데이터를 처리할 수 있도록 설계할 때 유용하다.

## 중요한 것은 제대로 된 구현

마지막으로, 이러한 데이터 구조를 설계할 때 중요한 고려 사항이 있다. **바로 성능이다.** 
스택이나 큐를 사용할 때, 모든 연산은 가능한 한 일정한 시간 내에 이루어져야 하며, 메모리 사용도 효율적이어야 한다. 
스택에 몇 개의 항목이 있느냐에 따라 메모리가 선형적으로 증가하고, 모든 연산이 일정한 시간 안에 끝나야 비로소 "진정한" 스택이나 큐라 할 수 있다. 
이러한 성능 요구사항을 충족하지 못하면, 그것은 스택이나 큐의 이름을 붙이기에는 적합하지 않은 것이다.

예를 들어 상단에 적은 스택과 큐의 구현 방향 지침을 어찌저찌 구현했다고 했다고 치자. 그러나 우리는 구현에 대해 더 강력한 기준으로 성능을 삼는다.
이러한 성능 사양을 충족하지 못하면 진정으로 스택과 큐라는 추상 데이터 타입에 대한 구현을 했다고 볼 수가 없다. 
